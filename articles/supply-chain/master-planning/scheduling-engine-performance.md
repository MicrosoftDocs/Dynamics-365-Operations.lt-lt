---
title: Planavimo mechanizmo efektyvumo didinimas
description: Šioje temoje pateikiama informacija apie planavimo mechanizmą ir apie tai, kaip padidinti jo efektyvumą.
author: ChristianRytt
manager: tfehr
ms.date: 09/03/2020
ms.topic: article
ms.prod: ''
ms.service: dynamics-ax-applications
ms.technology: ''
ms.search.form: ''
audience: Application User
ms.reviewer: kamaybac
ms.search.scope: Core, Operations
ms.custom: 19311
ms.assetid: 5ffb1486-2e08-4cdc-bd34-b47ae795ef0f
ms.search.region: Global
ms.search.industry: ''
ms.author: roxanad
ms.search.validFrom: 2020-09-03
ms.dyn365.ops.version: ''
ms.openlocfilehash: 18a9b7ed4cd26a806002fb1b4684de1e84f39889
ms.sourcegitcommit: c55fecae96b4bb27bc313ba10a97eddb9c91350a
ms.translationtype: HT
ms.contentlocale: lt-LT
ms.lasthandoff: 10/12/2020
ms.locfileid: "3989285"
---
# <a name="improve-scheduling-engine-performance"></a><span data-ttu-id="e7b20-103">Planavimo mechanizmo efektyvumo didinimas</span><span class="sxs-lookup"><span data-stu-id="e7b20-103">Improve scheduling engine performance</span></span>

[!include [banner](../includes/banner.md)]

<span data-ttu-id="e7b20-104">Išteklių planavimo mechanizmas naudojamas planuojant suplanuotų ir paskelbtų gamybos užsakymų maršrutus.</span><span class="sxs-lookup"><span data-stu-id="e7b20-104">The resource scheduling engine is used when scheduling routes for planned and released production orders.</span></span> <span data-ttu-id="e7b20-105">Iš pradžių mechanizmas buvo pristatytas kaip „Dynamics AX 2012“ dalis, o tada buvo kelis kartus tobulinamas.</span><span class="sxs-lookup"><span data-stu-id="e7b20-105">The engine was originally released as part of Dynamics AX 2012 and has gone through several improvements since its release.</span></span>

<span data-ttu-id="e7b20-106">[Užduočių planavimo problema](https://en.wikipedia.org/wiki/Job_shop_scheduling) yra itin sudėtinga kombinatorinė problema, kurios sprendimo laikas eksponentiškai auga didėjant kintamųjų skaičiui.</span><span class="sxs-lookup"><span data-stu-id="e7b20-106">The [job shop scheduling problem](https://en.wikipedia.org/wiki/Job_shop_scheduling) is an extremely complex combinatorial problem where solution time grows exponentially with the number of decision variables.</span></span> <span data-ttu-id="e7b20-107">Dažnai klientai sukonfigūruoja gamybos maršrutus ir susijusius duomenis taip, kad gautos planavimo problemos neįmanoma išspręsti per priimtiną laiką net ir naudojant pačią moderniausią įrangą.</span><span class="sxs-lookup"><span data-stu-id="e7b20-107">Oftentimes, customers set up production routes and related data in a way that results in a scheduling problem that can't be solved in reasonable time even on the most modern hardware.</span></span> <span data-ttu-id="e7b20-108">Ši tema padės jums perprasti planavimo modulį ir kaip konkretūs nustatymai gali turėti įtakos efektyvumui.</span><span class="sxs-lookup"><span data-stu-id="e7b20-108">This topic will help you understand the scheduling engine and how a specific setup can have influence on the performance.</span></span>

<span data-ttu-id="e7b20-109">Kai siekiama pagerinti planavimo efektyvumą, bendrosios rekomendacijos gali padėti sumažinti problemos, kurią turi išspręsti mechanizmas, sudėtingumą.</span><span class="sxs-lookup"><span data-stu-id="e7b20-109">When it comes to improving the performance of the scheduling, general guidelines recommend reducing the complexity of the problem the engine needs to solve.</span></span> <span data-ttu-id="e7b20-110">Kai kurie pagrindiniai veiksniai, kurie gali turėti įtakos efektyvumui:</span><span class="sxs-lookup"><span data-stu-id="e7b20-110">Some of the main factors that can affect performance include:</span></span>

- <span data-ttu-id="e7b20-111">Maršrutai su daugeliu operacijų</span><span class="sxs-lookup"><span data-stu-id="e7b20-111">Routes with many operations</span></span>
- <span data-ttu-id="e7b20-112">Maršrutai su lygiagrečiomis operacijomis</span><span class="sxs-lookup"><span data-stu-id="e7b20-112">Routes with parallel operations</span></span>
- <span data-ttu-id="e7b20-113">Operacijos, kurių išteklių kiekis yra didesnis už vienetą</span><span class="sxs-lookup"><span data-stu-id="e7b20-113">Operations with quantity of resources higher than one</span></span>
- <span data-ttu-id="e7b20-114">Operacijos su daugeliu galimų išteklių</span><span class="sxs-lookup"><span data-stu-id="e7b20-114">Operations with many applicable resources</span></span>
- <span data-ttu-id="e7b20-115">Naudojami kietieji saitai</span><span class="sxs-lookup"><span data-stu-id="e7b20-115">Use of hard links</span></span>
- <span data-ttu-id="e7b20-116">Naudojamas ribotas pajėgumas</span><span class="sxs-lookup"><span data-stu-id="e7b20-116">Use of finite capacity</span></span>
- <span data-ttu-id="e7b20-117">Naudojami skirtingi kalendoriai</span><span class="sxs-lookup"><span data-stu-id="e7b20-117">The number of different calendars used</span></span>
- <span data-ttu-id="e7b20-118">Darbo laiko intervalų skaičius per dieną kalendoriuje</span><span class="sxs-lookup"><span data-stu-id="e7b20-118">The number of working time slots per day in the calendar</span></span>
- <span data-ttu-id="e7b20-119">Bendra maršruto trukmė</span><span class="sxs-lookup"><span data-stu-id="e7b20-119">Total duration of the route</span></span>
- <span data-ttu-id="e7b20-120">Lygiagrečiai veikia keli planavimo mechanizmai</span><span class="sxs-lookup"><span data-stu-id="e7b20-120">Running multiple scheduling engines in parallel</span></span>

## <a name="overview-of-basic-scheduling-flow"></a><span data-ttu-id="e7b20-121">Pagrindinės planavimo eigos apžvalga</span><span class="sxs-lookup"><span data-stu-id="e7b20-121">Overview of basic scheduling flow</span></span>

<span data-ttu-id="e7b20-122">Norėdami suprasti, kokį poveikį sąranka gali turėti efektyvumui, svarbu suprasti apie proceso eigą tiek mechanizme, tiek susijusiame X++ kode.</span><span class="sxs-lookup"><span data-stu-id="e7b20-122">To understand how a given setup can affect performance, it is important to understand something about how the process flows, both inside the engine and in the X++ code that surrounds it.</span></span>

<span data-ttu-id="e7b20-123">Pagrindinį užsakymo planavimo procesą sudaro trys pagrindiniai veiksmai:</span><span class="sxs-lookup"><span data-stu-id="e7b20-123">The basic process of scheduling an order consists of three main steps:</span></span>

- <span data-ttu-id="e7b20-124">**Duomenų įkėlimas** – čia X++ duomenų modeliai paverčiami į mechanizmo vidinį duomenų modelį, kuris dirba su užduotimis ir apribojimais.</span><span class="sxs-lookup"><span data-stu-id="e7b20-124">**Loading data** – Here, the X++ data models are transformed into the engine's internal data model in the form of jobs and constraints.</span></span>
- <span data-ttu-id="e7b20-125">**Planavimas** – tai pagrindinis planavimo šaltinis, kuris apdoroja duotą modelį ir apribojimus bei generuoja rezultatą.</span><span class="sxs-lookup"><span data-stu-id="e7b20-125">**Scheduling** – This is the main source for scheduling that processes the given model and constraints, and generates a result.</span></span> <span data-ttu-id="e7b20-126">Šio proceso metu mechanizmas pagal poreikį prašys X++ darbo laiko informacijos ir esamų pajėgumo rezervavimo.</span><span class="sxs-lookup"><span data-stu-id="e7b20-126">During this process, the engine will request working time information and existing capacity reservations from X++ as needed.</span></span>
- <span data-ttu-id="e7b20-127">**Duomenų įrašymas** – sistemos rezultatą užduoties pajėgumo rezervavimo laiko intervalų forma apdoroja X++ kodas, kad įrašytų pajėgumų rezervavimus ir atnaujintų užduočių / darbo / užsakymo pradžios ir pabaigos laikus.</span><span class="sxs-lookup"><span data-stu-id="e7b20-127">**Save data** – The engine result in the form of job capacity reservation slots is processed by X++ code to save capacity reservations and update the start and end times of the jobs/operation/order.</span></span>

## <a name="load-data-into-the-engine"></a><span data-ttu-id="e7b20-128">Duomenų įkėlimas į mechanizmą</span><span class="sxs-lookup"><span data-stu-id="e7b20-128">Load data into the engine</span></span>

<span data-ttu-id="e7b20-129">Planavimo mechanizmo duomenų modelis yra labiau abstraktus nei „Supply Chain Management“ duomenų bazė, nes jis buvo sukurtas kaip bendrinis mechanizmas, galintis dirbti su skirtingais duomenų šaltiniais.</span><span class="sxs-lookup"><span data-stu-id="e7b20-129">The scheduling engine has a more abstract data model than the Supply Chain Management database because it has been built as a generic engine that can handle different sources of data.</span></span> <span data-ttu-id="e7b20-130">Maršruto, antrinių operacijų ir vykdymo laiko sąvokos turi būti „išverstos“ į bendrąją užduotį ir apribojimų modelį, su kuriuo dirba mechanizmas.</span><span class="sxs-lookup"><span data-stu-id="e7b20-130">The concepts of route, secondary operations, and run time need to be "translated" into the generic job and constraint model that the engine exposes.</span></span> <span data-ttu-id="e7b20-131">Modelio kūrimo logika didele dalimi yra pagrįsta verslo logika ir skiriasi priklausomai nuo šaltinio duomenų.</span><span class="sxs-lookup"><span data-stu-id="e7b20-131">The logic for building the model has a significant amount of business logic to it and is different depending on the source data.</span></span> <span data-ttu-id="e7b20-132">Atitinkama X++ klasė yra `WrkCtrScheduler`, kuri turi išvestines klases, skirtas planuojamiems gamybos užsakymams, paskelbtiems gamybos užsakymams ir projektų prognozėms.</span><span class="sxs-lookup"><span data-stu-id="e7b20-132">The responsible X++ class is `WrkCtrScheduler` and it has derived classes for planned production orders, released production orders, and project forecasts.</span></span>

<span data-ttu-id="e7b20-133">Pavyzdžiui, panagrinėkime gana paprastai atrodantį maršrutą, pavaizduotą toliau esančioje lentelėje ir paveikslėlyje.</span><span class="sxs-lookup"><span data-stu-id="e7b20-133">As an example, consider a route shown in the following table and image, which seems relatively simple.</span></span>

| <span data-ttu-id="e7b20-134">Oper.</span><span class="sxs-lookup"><span data-stu-id="e7b20-134">Oper.</span></span> <span data-ttu-id="e7b20-135">Nr.</span><span class="sxs-lookup"><span data-stu-id="e7b20-135">No.</span></span> | <span data-ttu-id="e7b20-136">Pirmenybė</span><span class="sxs-lookup"><span data-stu-id="e7b20-136">Priority</span></span> | <span data-ttu-id="e7b20-137">Nustatymo laikas</span><span class="sxs-lookup"><span data-stu-id="e7b20-137">Setup time</span></span> | <span data-ttu-id="e7b20-138">Apdorojimo laikas</span><span class="sxs-lookup"><span data-stu-id="e7b20-138">Run time</span></span> | <span data-ttu-id="e7b20-139">Laukimo darbo grupėje laikas po</span><span class="sxs-lookup"><span data-stu-id="e7b20-139">Queue time after</span></span> | <span data-ttu-id="e7b20-140">Išteklių kiekis</span><span class="sxs-lookup"><span data-stu-id="e7b20-140">Quantity of resources</span></span> | <span data-ttu-id="e7b20-141">Paskesnis</span><span class="sxs-lookup"><span data-stu-id="e7b20-141">Next</span></span> |
| --- | --- | --- | --- | --- | --- | --- |
| <span data-ttu-id="e7b20-142">10</span><span class="sxs-lookup"><span data-stu-id="e7b20-142">10</span></span> | <span data-ttu-id="e7b20-143">Pirminis</span><span class="sxs-lookup"><span data-stu-id="e7b20-143">Primary</span></span> | <span data-ttu-id="e7b20-144">1.00</span><span class="sxs-lookup"><span data-stu-id="e7b20-144">1.00</span></span> | <span data-ttu-id="e7b20-145">2.00</span><span class="sxs-lookup"><span data-stu-id="e7b20-145">2.00</span></span> | | <span data-ttu-id="e7b20-146">1</span><span class="sxs-lookup"><span data-stu-id="e7b20-146">1</span></span> | <span data-ttu-id="e7b20-147">20</span><span class="sxs-lookup"><span data-stu-id="e7b20-147">20</span></span> |
| <span data-ttu-id="e7b20-148">10</span><span class="sxs-lookup"><span data-stu-id="e7b20-148">10</span></span> | <span data-ttu-id="e7b20-149">Antrinis&nbsp;1</span><span class="sxs-lookup"><span data-stu-id="e7b20-149">Secondary&nbsp;1</span></span> | | | | <span data-ttu-id="e7b20-150">1</span><span class="sxs-lookup"><span data-stu-id="e7b20-150">1</span></span> | <span data-ttu-id="e7b20-151">20</span><span class="sxs-lookup"><span data-stu-id="e7b20-151">20</span></span> |
| <span data-ttu-id="e7b20-152">20</span><span class="sxs-lookup"><span data-stu-id="e7b20-152">20</span></span> | <span data-ttu-id="e7b20-153">Pirminis</span><span class="sxs-lookup"><span data-stu-id="e7b20-153">Primary</span></span> | | <span data-ttu-id="e7b20-154">3.00</span><span class="sxs-lookup"><span data-stu-id="e7b20-154">3.00</span></span> | <span data-ttu-id="e7b20-155">1.00</span><span class="sxs-lookup"><span data-stu-id="e7b20-155">1.00</span></span> | <span data-ttu-id="e7b20-156">3</span><span class="sxs-lookup"><span data-stu-id="e7b20-156">3</span></span> | <span data-ttu-id="e7b20-157">0</span><span class="sxs-lookup"><span data-stu-id="e7b20-157">0</span></span> |

<span data-ttu-id="e7b20-158">![Pavyzdinio maršruto diagrama](media/scheduling-engine-route.png "Pavyzdinio maršruto diagrama")</span><span class="sxs-lookup"><span data-stu-id="e7b20-158">![Example rout diagram](media/scheduling-engine-route.png "Example rout diagram")</span></span>

<span data-ttu-id="e7b20-159">Siunčiant į variklį, jis suskirstomas į aštuonias užduotis, kaip parodyta toliau esančiame paveikslėlyje (pasirinkite paveikslėlį, kad jį padidintumėte).</span><span class="sxs-lookup"><span data-stu-id="e7b20-159">When sending this to the engine, it is split out into eight jobs, as shown in the following illustration (select the image to enlarge it).</span></span>

<span data-ttu-id="e7b20-160">[![Planavimo mechanizmo užduotys](media/scheduling-engine-jobs.png "Planavimo mechanizmo užduotys")](media/scheduling-engine-jobs-large.png)</span><span class="sxs-lookup"><span data-stu-id="e7b20-160">[![Scheduling engine jobs](media/scheduling-engine-jobs.png "Scheduling engine jobs")](media/scheduling-engine-jobs-large.png)</span></span>

<span data-ttu-id="e7b20-161">Įprastinis dviejų užduočių saitas yra `FinishStart` t. y. vienos užduoties pabaigos laikas turi būti ankstesnis nei kitos užduoties pradžios laikas.</span><span class="sxs-lookup"><span data-stu-id="e7b20-161">The standard link between two jobs is `FinishStart`, meaning that the end time of one job must be before the start time of another job.</span></span> <span data-ttu-id="e7b20-162">Kadangi sąranka turi būti atliekama to paties ištekliaus, kuris vėliau vykdys procesą, tarp jų yra `OnSameResource` apribojimų.</span><span class="sxs-lookup"><span data-stu-id="e7b20-162">Because the setup must be performed by the same resource that will later do the process, there are `OnSameResource` constraints between them.</span></span> <span data-ttu-id="e7b20-163">Tarp 10 pirminės ir antrinės operacijų yra `StartStart` ir `FinishFinish` saitai, o tai reiškia, kad abi užduotys turi ir prasidėti ir baigtis tuo pačiu metu, taip pat yra `NotOnSameResource` apribojimų, neleidžiančių naudoti to paties ištekliaus pirminei ir antrinei operacijai.</span><span class="sxs-lookup"><span data-stu-id="e7b20-163">Between the jobs for primary and secondary operation for 10, there are `StartStart` and `FinishFinish` links, which means that the jobs must both start and end at the same time, and there are `NotOnSameResource` constraints, which will prevent the same resource for primary and secondary.</span></span>

<span data-ttu-id="e7b20-164">Atliekant 20 operaciją, kai nustatytas išteklių kiekis yra 3, proceso užduotis suskirstyta į tris atskiras užduotis, be to, visos užduotys turi būti vykdomos tuo pačiu metu.</span><span class="sxs-lookup"><span data-stu-id="e7b20-164">For operation 20, where the quantity of resources has been set to 3, the process job has been split into three distinct jobs where all the jobs must run at the exact same time.</span></span>
<span data-ttu-id="e7b20-165">Šiuo atveju maršruto grupė buvo nustatyta ne tam, kad rezervuotų pajėgumą eilei pasibaigus laikui, todėl po to esančiai eilei skirta tik viena užduotis.</span><span class="sxs-lookup"><span data-stu-id="e7b20-165">In this case, the route group has been set up to not reserve capacity for queue after times, which is why there is only a single job for the queue after.</span></span>

<span data-ttu-id="e7b20-166">Planavimo mechanizmas dirba tik su užduotimis ir nedirba su operacijomis.</span><span class="sxs-lookup"><span data-stu-id="e7b20-166">The scheduling engine only understands the concepts of jobs and has no notion of operations.</span></span> <span data-ttu-id="e7b20-167">Tai reiškia, kad atliekant operacijų planavimą operacijos taip pat taip yra išskaidomos į užduotis, nors jos nėra saugomos duomenų bazėje.</span><span class="sxs-lookup"><span data-stu-id="e7b20-167">This means that when doing operation scheduling, the operations are also split into jobs, although these will not be persisted in the database.</span></span>

<span data-ttu-id="e7b20-168">Kiekvienai užduočiai taip pat nurodysime užduoties pajėgumo poreikį (reikiamą sekundžių skaičių).</span><span class="sxs-lookup"><span data-stu-id="e7b20-168">For each job, we will also define what the job capacity requirement is (the number of seconds required).</span></span> <span data-ttu-id="e7b20-169">Atsižvelgiant į tai, kaip buvo nurodyti išteklių poreikiai, kiekvienai užduočiai taip pat gali būti siunčiamas visų galimų išteklių, kurie gali būti naudojami užduočiai vykdyti, ir pajėgumo reikalavimų konkretiems ištekliams sąrašas.</span><span class="sxs-lookup"><span data-stu-id="e7b20-169">Depending on how the resource requirements have been defined, we may also, for each job, send a list of all the potential applicable resources that the job could run on and what the capacity requirement is for that specific resource.</span></span> <span data-ttu-id="e7b20-170">Nepaisant to, kad kuriant modelį yra siunčiamas tinkamų išteklių sąrašas, mechanizmas vis tiek turi užtikrinti, kad išteklių priskyrimas yra tinkamas visai užduoties trukmei.</span><span class="sxs-lookup"><span data-stu-id="e7b20-170">Even though the list of applicable resources is sent when building the model, the engine will still need to ensure that the resource assignment is actually valid for the entire job duration.</span></span>

## <a name="scheduling-engine-internals"></a><span data-ttu-id="e7b20-171">Planavimo mechanizmo vidinė sandara</span><span class="sxs-lookup"><span data-stu-id="e7b20-171">Scheduling engine internals</span></span>

### <a name="scheduling-engine-interface"></a><span data-ttu-id="e7b20-172">Planavimo mechanizmo sąsaja</span><span class="sxs-lookup"><span data-stu-id="e7b20-172">Scheduling engine interface</span></span>

<span data-ttu-id="e7b20-173">Norėdami suprasti vidinę mechanizmo sandarą, geriausia apžvelgti iš išorės prieinamas funkcijas.</span><span class="sxs-lookup"><span data-stu-id="e7b20-173">To get an idea of how the engine works internally, it is best to look at the functionality it exposes externally.</span></span> <span data-ttu-id="e7b20-174">X++ pagrindinė sąsaja yra `WrkCtrSchedulerEngineInterface`.</span><span class="sxs-lookup"><span data-stu-id="e7b20-174">In X++, the main interface is `WrkCtrSchedulerEngineInterface`.</span></span> <span data-ttu-id="e7b20-175">Ji turi metodus, aprašytus toliau esančiuose poskyriuose.</span><span class="sxs-lookup"><span data-stu-id="e7b20-175">It has the methods described in the following subsections.</span></span>

#### <a name="general-engine"></a><span data-ttu-id="e7b20-176">Bendrasis mechanizmas</span><span class="sxs-lookup"><span data-stu-id="e7b20-176">General engine</span></span>

| <span data-ttu-id="e7b20-177">**Metodas**</span><span class="sxs-lookup"><span data-stu-id="e7b20-177">**Method**</span></span> | <span data-ttu-id="e7b20-178">**Paskirtis**</span><span class="sxs-lookup"><span data-stu-id="e7b20-178">**Purpose**</span></span> |
| --- | --- |
| `run` | <span data-ttu-id="e7b20-179">Suplanuoja visas įkeltas užduotis ir grąžina klaidos kodą.</span><span class="sxs-lookup"><span data-stu-id="e7b20-179">Schedules all loaded jobs and returns the error code.</span></span> |
| `getJobSchedulingSequenceResult` | <span data-ttu-id="e7b20-180">Gaunamas konkrečios užduoties nustatytos sekos planavimo rezultatas ir pirmoji klaidos užduotis.</span><span class="sxs-lookup"><span data-stu-id="e7b20-180">Gets the scheduling result and the first error job for the sequence identified by a specific job.</span></span> |
| `validateJobCapacityReservations` | <span data-ttu-id="e7b20-181">Patvirtinami visų mechanizmo saugomų užduočių pajėgumų rezervavimai.</span><span class="sxs-lookup"><span data-stu-id="e7b20-181">Validates the capacity reservations for all the jobs stored by the engine.</span></span> |
| `setReservationsTimeStamp` | <span data-ttu-id="e7b20-182">Į variklį siunčiama laiko žyma, nustatyta mechanizmo atmintinėje suplanuotų užduočių visiems naujiems pajėgumų rezervavimams.</span><span class="sxs-lookup"><span data-stu-id="e7b20-182">Sends a timestamp to the engine set on all new capacity reservations for the scheduled jobs in the cache of the engine.</span></span> |
| `addPropertyToGroupAggregation` | <span data-ttu-id="e7b20-183">Kai pajėgumai sujungiami, prie naudojamų ypatybių rinkinio pridedamas ypatybės prefiksas.</span><span class="sxs-lookup"><span data-stu-id="e7b20-183">Adds a property prefix to the set of properties used when capacity is aggregated.</span></span> |
| `addResource` | <span data-ttu-id="e7b20-184">Prie planavimo mechanizmo išteklių telkinio pridedamas išteklius.</span><span class="sxs-lookup"><span data-stu-id="e7b20-184">Adds a resource to the scheduling engine resource pool.</span></span> |
| `addResourceGroup` | <span data-ttu-id="e7b20-185">Prie planavimo mechanizmo išteklių grupių telkinio pridedama išteklių grupė.</span><span class="sxs-lookup"><span data-stu-id="e7b20-185">Adds a resource group to the scheduling engine resource group pool.</span></span> |
| `addResourceGroupMembership` | <span data-ttu-id="e7b20-186">Prie išteklių grupės kaip narys pridedamas išteklius.</span><span class="sxs-lookup"><span data-stu-id="e7b20-186">Adds a resource as a member to a resource group.</span></span> |
| `addOptimizationGoal` | <span data-ttu-id="e7b20-187">Pridedamas planavimo optimizavimo tikslas (trukmė arba prioritetas).</span><span class="sxs-lookup"><span data-stu-id="e7b20-187">Adds a scheduling optimization goal (duration or priority).</span></span> |

#### <a name="individual-jobs"></a><span data-ttu-id="e7b20-188">Atskiros užduotys</span><span class="sxs-lookup"><span data-stu-id="e7b20-188">Individual jobs</span></span>

| <span data-ttu-id="e7b20-189">**Metodas**</span><span class="sxs-lookup"><span data-stu-id="e7b20-189">**Method**</span></span> | <span data-ttu-id="e7b20-190">**Paskirtis**</span><span class="sxs-lookup"><span data-stu-id="e7b20-190">**Purpose**</span></span> |
| --- | --- |
| `addJobInfo` | <span data-ttu-id="e7b20-191">Pridedamas užduoties informacijos įrašas, kuris praneša varikliui apie užduotį, kuri turi būti suplanuota.</span><span class="sxs-lookup"><span data-stu-id="e7b20-191">Adds a job information record that informs the engine about a job that should be scheduled.</span></span> |
| `addConstraintJobEndsAt` | <span data-ttu-id="e7b20-192">Pridedamas apribojimas, kad užduotis turi baigtis nurodytą dieną ir nurodytu laiku.</span><span class="sxs-lookup"><span data-stu-id="e7b20-192">Adds a constraint that a job should end at a specified date and time.</span></span> |
| `addConstraintJobStartsAt` | <span data-ttu-id="e7b20-193">Pridedamas apribojimas, kad užduotis turi prasidėti nurodytą dieną ir nurodytu laiku.</span><span class="sxs-lookup"><span data-stu-id="e7b20-193">Adds a constraint that a job should start at a specified date and time.</span></span> |
| `addConstraintMaxJobDays` | <span data-ttu-id="e7b20-194">Nurodomas apribojimas, kurį užduotis gali tęstis nurodytą maksimalų dienų skaičių.</span><span class="sxs-lookup"><span data-stu-id="e7b20-194">Defines the constraint that a job can span over a specified maximal number of days.</span></span> |
| `addConstraintResourceRequirement` | <span data-ttu-id="e7b20-195">Pridedamas apribojimas, kad užduotis turi būti suplanuota naudojant tam tikrą išteklių.</span><span class="sxs-lookup"><span data-stu-id="e7b20-195">Adds the constraint that the job must be scheduled on a specific resource.</span></span> |
| `addJobBindPriority` | <span data-ttu-id="e7b20-196">Pridedamas (užduoties, apribojimo lygio) poros užduoties susiejimo prioritetas.</span><span class="sxs-lookup"><span data-stu-id="e7b20-196">Adds a job bind priority for a (job, constraint level) pair.</span></span> <span data-ttu-id="e7b20-197">Didesnė prioriteto reikšmė reiškia, kad užduoties kintamieji bus susieti anksčiau.</span><span class="sxs-lookup"><span data-stu-id="e7b20-197">A higher priority value means the job variables will be bound earlier.</span></span> <span data-ttu-id="e7b20-198">Užduotis toje pačioje sekoje bus apdorota prieš užduotis, kurių prioriteto reikšmė yra mažesnė.</span><span class="sxs-lookup"><span data-stu-id="e7b20-198">The job will be processed before jobs with lower priority value in the same sequence.</span></span> |
| `addJobCapacity` | <span data-ttu-id="e7b20-199">Prideda užduoties pajėgumo informaciją (pvz., reikalingą užduoties vykdymo laiką), kuri nepriklauso nuo to, kuris išteklius naudojamas užduoties vykdymui.</span><span class="sxs-lookup"><span data-stu-id="e7b20-199">Adds capacity load information for a job (like the required job runtime) independent on which resource the job runs on.</span></span> |
| `addJobResourceCapacity` | <span data-ttu-id="e7b20-200">Prideda išteklių prie išteklių, kurie gali būti naudojami užduočiai atlikti, rinkinio ir nurodo pajėgumą, kurio reikia, kai vykdymui naudojamas šis išteklius.</span><span class="sxs-lookup"><span data-stu-id="e7b20-200">Adds a resource to the set of resources that may be used to perform a job, and states the capacity required when running on that resource.</span></span> |
| `addJobGoal` | <span data-ttu-id="e7b20-201">Prideda užduoties tikslo informaciją konkrečiam apribojimo lygiui (anksčiausias pabaigos laikas arba vėliausias pradžios laikas).</span><span class="sxs-lookup"><span data-stu-id="e7b20-201">Adds job goal information for a specific constraint level (earliest end time or latest start time).</span></span> |
| `addJobResourcePriority` | <span data-ttu-id="e7b20-202">Prideda prioritetą, kuris naudojamas planuojant užduotį ištekliuje.</span><span class="sxs-lookup"><span data-stu-id="e7b20-202">Adds the priority to use when a job is scheduled on a resource.</span></span> |
| `addJobResourceRuntime` | <span data-ttu-id="e7b20-203">Nurodo užduoties laiką, kuris priklauso nuo ištekliaus, kurs yra suplanuotas užduoties vykdymui.</span><span class="sxs-lookup"><span data-stu-id="e7b20-203">Specifies a job time that is dependent of the resource the job will be scheduled on.</span></span> |
| `addJobRuntime` | <span data-ttu-id="e7b20-204">Nurodo užduoties laiką, kuris nepriklauso nuo ištekliaus, kurs bus suplanuotas užduoties vykdymui.</span><span class="sxs-lookup"><span data-stu-id="e7b20-204">Specifies a job time that is independent of the resource on which the job will be scheduled.</span></span> |
| `scheduleJobOnResourceGroup` | <span data-ttu-id="e7b20-205">Žymi užduotį, skirtą išteklių grupės lygio planavimui.</span><span class="sxs-lookup"><span data-stu-id="e7b20-205">Marks a job for scheduling on the resource group level.</span></span> |
| `setJobResourcePreemptionAllowed` | <span data-ttu-id="e7b20-206">Nustato, ar leidžiama atlikti užduoties, naudojančios išteklių, pertraukiamą (jei mechanizmui leidžiama planuoti užduotį naudojant nenuoseklius pajėgumo intervalus).</span><span class="sxs-lookup"><span data-stu-id="e7b20-206">Sets whether preemption is allowed for a job on a resource (if engine is allowed to schedule the job in noncontiguous capacity slots).</span></span> |
| `setRequiredNumberOfResources` | <span data-ttu-id="e7b20-207">Nustato išteklių, reikalingų užduočiai planuoti, skaičių (tik operacijų planavimui).</span><span class="sxs-lookup"><span data-stu-id="e7b20-207">Sets the number of resources required to schedule a job (only for operations scheduling).</span></span> |

#### <a name="constraints-between-jobs"></a><span data-ttu-id="e7b20-208">Užduočių apribojimai</span><span class="sxs-lookup"><span data-stu-id="e7b20-208">Constraints between jobs</span></span>

| <span data-ttu-id="e7b20-209">**Metodas**</span><span class="sxs-lookup"><span data-stu-id="e7b20-209">**Method**</span></span> | <span data-ttu-id="e7b20-210">**Paskirtis**</span><span class="sxs-lookup"><span data-stu-id="e7b20-210">**Purpose**</span></span> |
| --- | --- |
| `addJobLink` | <span data-ttu-id="e7b20-211">Pridedamas saitas (pvz., pabaiga \>pradžia) tarp dviejų užduočių.</span><span class="sxs-lookup"><span data-stu-id="e7b20-211">Adds a link (such as finish\>start) between two jobs.</span></span> |
| `addConstraintEndsDelayed` | <span data-ttu-id="e7b20-212">Nurodomas apribojimas, kad užduotis negali baigtis prieš kitas užduotis, atsižvelgiant į tam tikrą delsos laiką.</span><span class="sxs-lookup"><span data-stu-id="e7b20-212">Defines the constraint that a job cannot end before another jobs end plus some delay time.</span></span> |
| `addConstraintJobListWorkingTimeIntersect` | <span data-ttu-id="e7b20-213">Pridedamas apribojimas, kad, esant dviem užduočių naudojamiems ištekliams, užduotims rezervuoti pajėgumo intervalai turi būti pateikti į susikertančius darbo laikus.</span><span class="sxs-lookup"><span data-stu-id="e7b20-213">Adds a constraint that the capacity slots reserved for the jobs must be on the intersecting working times for the two resources used by the jobs.</span></span> |
| `addConstraintJobOverlap` | <span data-ttu-id="e7b20-214">Pridedamas apribojimas, nurodantis, kaip užduotys išdėstomos, kai nurodytas prekės kiekis gali būti perkeltas tarp dviejų išteklių, o pirmasis išteklius dar nebaigė apdorojimo, kad apdorojimą galėtų pradėti antrasis išteklius.</span><span class="sxs-lookup"><span data-stu-id="e7b20-214">Add a constraint that defines how jobs are sequenced when a given quantity of an item can be moved between two resources while the first resource is still not finished processing, so that the second resource can start processing.</span></span> |
| `addConstraintNotOnSameResource` | <span data-ttu-id="e7b20-215">Pridedamas apribojimas, kad dvi užduotys negali būti suplanuotos naudojant tą patį išteklių.</span><span class="sxs-lookup"><span data-stu-id="e7b20-215">Adds a constraint that two jobs should not be scheduled on the same resource.</span></span> |
| `addConstraintOnSameResource` | <span data-ttu-id="e7b20-216">Pridedamas apribojimas, kad dvi užduotys privalo naudoti tą patį išteklių.</span><span class="sxs-lookup"><span data-stu-id="e7b20-216">Adds a constraint that two jobs must be using the same resource.</span></span> |
| `addJobSameReservations` | <span data-ttu-id="e7b20-217">Pridedamas apribojimas, kad galutiniai užduoties pajėgumų rezervavimai turi būti tiems patiems laiko intervalams kaip ir pirminės užduoties.</span><span class="sxs-lookup"><span data-stu-id="e7b20-217">Adds a constraint that a job must end up having capacity reservations for the same time slots as the primary job.</span></span> |
| `setPrimaryParallelJob` | <span data-ttu-id="e7b20-218">Pridedama informacija apie tai, kuri užduotis yra pirminė užduotis lygiagrečių užduočių rinkinyje.</span><span class="sxs-lookup"><span data-stu-id="e7b20-218">Adds information about what job is the primary job in a set of parallel jobs.</span></span> |

### <a name="solver"></a><span data-ttu-id="e7b20-219">Sprendimo priemonė</span><span class="sxs-lookup"><span data-stu-id="e7b20-219">Solver</span></span>

<span data-ttu-id="e7b20-220">Pats mechanizmas iš esmės yra specializuota sprendimo su apribojimais priemonė su pridėta specialia euristika.</span><span class="sxs-lookup"><span data-stu-id="e7b20-220">The engine itself is essentially a specialized constraint solver with custom heuristics added.</span></span> <span data-ttu-id="e7b20-221">Sprendimo priemonės pagrindą sudaro du pagrindiniai elementai: kintamieji ir apribojimai.</span><span class="sxs-lookup"><span data-stu-id="e7b20-221">The solver is based on two main elements: variables and constraints.</span></span>

#### <a name="variable"></a><span data-ttu-id="e7b20-222">Kintamasis</span><span class="sxs-lookup"><span data-stu-id="e7b20-222">Variable</span></span>

<span data-ttu-id="e7b20-223">Kintamasis atitinka galimų verčių sritį.</span><span class="sxs-lookup"><span data-stu-id="e7b20-223">A variable represents a domain of possible values.</span></span> <span data-ttu-id="e7b20-224">Planavimo mechanizme yra dviejų tipų kintamieji:</span><span class="sxs-lookup"><span data-stu-id="e7b20-224">Scheduling engine has two types of variables:</span></span>

- <span data-ttu-id="e7b20-225">**Datos ir laiko kintamasis** – jo sritis yra visos galimos datos ir laikai, o pačią sritį galima apriboti perkeliant kintamojo apatinę ir viršutinę laiko ribas arčiau viena kitos.</span><span class="sxs-lookup"><span data-stu-id="e7b20-225">**DateTime variable** - Has a domain of all dates and times, and the domain can be restricted by moving the lower and upper bound for the time of the variable closer to each other.</span></span>
- <span data-ttu-id="e7b20-226">**Ištekliaus kintamasis** – jo sritis yra galimi ištekliai, o pačią sritį galima apriboti pašalinant išteklius iš sąrašo.</span><span class="sxs-lookup"><span data-stu-id="e7b20-226">**Resource variable** - Has a domain of applicable resources, and the domain can be restricted by eliminating resources from the list.</span></span>

#### <a name="constraint"></a><span data-ttu-id="e7b20-227">Apribojimas</span><span class="sxs-lookup"><span data-stu-id="e7b20-227">Constraint</span></span>

<span data-ttu-id="e7b20-228">Apribojimas taikomas kintamiesiems apribodamas jų sritis, tačiau kartu priklauso nuo kintamųjų, todėl yra suaktyvinamas pasikeitus kintamiesiems.</span><span class="sxs-lookup"><span data-stu-id="e7b20-228">A constraint acts on variables by restricting their domains, but it also depends on variables so it gets activated when variables change.</span></span> <span data-ttu-id="e7b20-229">„Apribojimų taikymo“ procesas yra, kai apribojimas atlieka pagrindinę savo funkciją, o tada sėkmingai pateikia rezultatą pagrindinei loginei procedūrai.</span><span class="sxs-lookup"><span data-stu-id="e7b20-229">The process of "constraint propagation" is when a constraint performs its main function and reports back to the main logic if successful.</span></span>

<span data-ttu-id="e7b20-230">Kintamasis laikomas susietu, kai jo negalima apriboti dar labiau. Datos ir laiko kintamojo atveju tai reiškia, kad viršutinė ir apatinė riba sutampa, o ištekliaus kintamojo atveju tai reiškia, kad yra tik vienas atitinkamas išteklius.</span><span class="sxs-lookup"><span data-stu-id="e7b20-230">A variable is considered bound when it can't be restricted further, which for DateTime variable means that upper and lower bound is the same, and for the Resource variable that it has only a single applicable resource.</span></span> <span data-ttu-id="e7b20-231">Kai visi kintamieji yra susieti, sprendimas yra rastas.</span><span class="sxs-lookup"><span data-stu-id="e7b20-231">When all variables are bound, a solution is found.</span></span>

### <a name="constraint-levels"></a><span data-ttu-id="e7b20-232">Apribojimo lygiai</span><span class="sxs-lookup"><span data-stu-id="e7b20-232">Constraint levels</span></span>

<span data-ttu-id="e7b20-233">Kai planavimas vykdomas kaip medžiagų poreikio planavimo (MRP) padengimo etapo dalis, atgalinis užsakymų planavimas bus vykdomas nuo poreikio datos.</span><span class="sxs-lookup"><span data-stu-id="e7b20-233">When scheduling is executed as part of the material requirements planning (MRP) coverage phase, the orders will be scheduled backward from requirement date.</span></span> <span data-ttu-id="e7b20-234">Tačiau, jei neįmanoma rasti grafiko, kuris prasideda šiandien arba vėliau ir baigiasi prieš poreikio datą, tada planavimo kryptis pasikeis ir planavimas bus vykdomas nuo šiandienos.</span><span class="sxs-lookup"><span data-stu-id="e7b20-234">However, if it is not possible to find a schedule that starts today or later and ends before the requirement date, then the scheduling direction will change to forward from today.</span></span>

<span data-ttu-id="e7b20-235">Ši pagrindinė verslo taisyklė tvarkoma apribojimus suskirstant į lygius.</span><span class="sxs-lookup"><span data-stu-id="e7b20-235">This main business rule is handled by organizing the constraints in levels.</span></span> <span data-ttu-id="e7b20-236">Jei naudojant aukščiausio lygio apribojimus sprendimo rasti nepavyksta, tada atitinkamo lygio apribojimai yra sumažinami ir bandoma taikyti žemesnio lygio apribojimus.</span><span class="sxs-lookup"><span data-stu-id="e7b20-236">If no solution is found when using the constraints on the highest level, then the constraints on that level are all dropped, and the lower level is tried.</span></span> <span data-ttu-id="e7b20-237">Praktikoje tai reiškia, kad vykdant atgalinį planavimą modelis apims 1 lygį su vėliausio pradžios laiko užduoties tikslais esant maksimalaus pabaigos laiko apribojimui (poreikio data), ir 0 lygį su anksčiausio pabaigos laiko užduoties tikslais esant šiandienos minimalaus pradžios laiko apribojimui.</span><span class="sxs-lookup"><span data-stu-id="e7b20-237">In praxis, this means that for backward scheduling the model will contain a level 1 with job goals of latest start time given a maximum end time constraint (the requirement date), and a level 0 with job goals of earliest end time and given a minimum start time constraint of today.</span></span>

### <a name="algorithm"></a><span data-ttu-id="e7b20-238">Algoritmas</span><span class="sxs-lookup"><span data-stu-id="e7b20-238">Algorithm</span></span>

<span data-ttu-id="e7b20-239">Pagrindiniai mechanizmo algoritmo veiksmai:</span><span class="sxs-lookup"><span data-stu-id="e7b20-239">The main steps of the engine algorithm are:</span></span>

1. <span data-ttu-id="e7b20-240">Suraskite sekas (užduočių grandines), kurias galima spręsti atskirai.</span><span class="sxs-lookup"><span data-stu-id="e7b20-240">Find sequences (job chains) which can be solved separately.</span></span>
1. <span data-ttu-id="e7b20-241">Pabandykite surasti pradinį aukščiausio apribojimo lygio sekos sprendimą.</span><span class="sxs-lookup"><span data-stu-id="e7b20-241">Try to find an initial solution for the sequence for the highest constraint level.</span></span>
    1. <span data-ttu-id="e7b20-242">Surikiuokite sekoje esančias užduotis pagal užduoties tikslą ir prioritetus, kad būtų galima surasti pradinę užduotį.</span><span class="sxs-lookup"><span data-stu-id="e7b20-242">Sort the jobs in the sequence based on job goal and priorities, such that a start job can be found.</span></span>
    1. <span data-ttu-id="e7b20-243">Nagrinėkite užduotis nurodyta tvarka:</span><span class="sxs-lookup"><span data-stu-id="e7b20-243">Loop the jobs in the following sequence:</span></span>
        1. <span data-ttu-id="e7b20-244">Suraskite visus apribojimus, kuriuos reikia pritaikyti, ir atlikite pritaikymo procedūrą.</span><span class="sxs-lookup"><span data-stu-id="e7b20-244">Find all constraints that need to be propagated and run propagation.</span></span>
        1. <span data-ttu-id="e7b20-245">Jei visi užduoties kintamieji yra susieti, rastas užduoties sprendimas.</span><span class="sxs-lookup"><span data-stu-id="e7b20-245">If all variables for the job have been bound, then a solution for that job has been found.</span></span>
        1. <span data-ttu-id="e7b20-246">Jeigu nepažeidžiant apribojimų nepavyko rasti vieno iš kintamųjų, tada atšaukite kintamojo susiejimą, išbandykite kitą sričiai priklausiančią vertę (ištekliaus kintamajam) ir iš naujo atlikite apribojimo pritaikymo procedūrą.</span><span class="sxs-lookup"><span data-stu-id="e7b20-246">If one of the variables could not be bound without violating the constraints, then roll back the variable binding, try a different value in the domain (for resource variable), and rerun the constraint propagation.</span></span>
1. <span data-ttu-id="e7b20-247">Jei sprendimo nepavyko rasti, visi dabartinio apribojimo lygio apribojimai pašalinami, apribojimo lygis sumažinamas (jei galimi žemesni lygiai) ir sprendimo paieška kartojama su nauju apribojimų rinkiniu.</span><span class="sxs-lookup"><span data-stu-id="e7b20-247">If no solution was found, then all constraints on the current constraint level is removed, the constraint level lowered (if any lower levels are available) and solution search retried with the new set of constraint.</span></span>
1. <span data-ttu-id="e7b20-248">Jei rastas patenkinamas sprendimas, pradedamas optimizavimo etapas, kurio metu bandoma rasti geresnį sprendimą, kol pasibaigs optimizavimui skirtas laikas arba bus išnagrinėti visi išteklių deriniai.</span><span class="sxs-lookup"><span data-stu-id="e7b20-248">If a feasible solution was found, then the optimization phase is started, which will try to find a better solution until the optimization timeout is reached or all resource combinations have been exhausted.</span></span>

<span data-ttu-id="e7b20-249">Sprendimo su apribojimais priemonė nėra susijusi su planavimo algoritmo detalėmis.</span><span class="sxs-lookup"><span data-stu-id="e7b20-249">The constraint solver is not aware of the specifics of the scheduling algorithm.</span></span> <span data-ttu-id="e7b20-250">Darbo efektyvumas priklauso nuo įvairių apribojimų apibrėžimo ir jų derinio.</span><span class="sxs-lookup"><span data-stu-id="e7b20-250">It is in the definition and combination of the various constraints that the "magic" happens.</span></span>

### <a name="determining-working-times"></a><span data-ttu-id="e7b20-251">Darbo laiko nustatymas</span><span class="sxs-lookup"><span data-stu-id="e7b20-251">Determining working times</span></span>

<span data-ttu-id="e7b20-252">Didelė mechanizmo (vidinių) apribojimų dalis kontroliuoja darbo laiką ir ištekliaus pajėgumą.</span><span class="sxs-lookup"><span data-stu-id="e7b20-252">A large part of the (internal) constraints in the engine controls the working time and capacity of a resource.</span></span> <span data-ttu-id="e7b20-253">Iš esmės tikslas yra išnagrinėti ištekliaus darbo laiko intervalus nuo nurodyto taško nurodyta kryptimi ir rasti pakankamai ilgą intervalą, į kurį galėtų tilpti reikalaujamas užduočių pajėgumas (laikas).</span><span class="sxs-lookup"><span data-stu-id="e7b20-253">Essentially, the task is to traverse the working time slots for a resource from a given point in a given direction, and find a long enough interval in which the jobs required capacity (time) can fit.</span></span>

<span data-ttu-id="e7b20-254">Norint tai padaryti, mechanizmui reikia žinoti ištekliaus darbo laikus.</span><span class="sxs-lookup"><span data-stu-id="e7b20-254">To do this, the engine needs to know the working times of a resource.</span></span> <span data-ttu-id="e7b20-255">Skirtingai nuo pagrindinių modelio duomenų, darbo laikai yra *įkeliami atidėtai*, o tai reiškia, kad jie įkeliami į mechanizmą pagal poreikį.</span><span class="sxs-lookup"><span data-stu-id="e7b20-255">Opposite to the main model data, the working times are *lazy loaded*, meaning that they are loaded into the engine as needed.</span></span> <span data-ttu-id="e7b20-256">Priežastis taikyti tokį metodą yra ta, kad dažnai „Supply Chain Management“ darbo laikai yra iš labai ilgo laikotarpio kalendoriaus ir dažniausiai yra daug kalendorių, todėl įkeliamų duomenų apimtis gali būti gana didelė.</span><span class="sxs-lookup"><span data-stu-id="e7b20-256">The reason for this approach is that there are often working times in Supply Chain Management for a calendar for a very long period and typically many calendars exist so the data would be quite large to pre-load.</span></span>

<span data-ttu-id="e7b20-257">Mechanizmo reikalaujama kalendoriaus informacija įkeliama dalimis, naudojant X++ klasės metodą `WrkCtrSchedulingInteropDataProvider.getWorkingTimes`.</span><span class="sxs-lookup"><span data-stu-id="e7b20-257">Calendar information is requested by the engine in chunks, by invoking the X++ class method `WrkCtrSchedulingInteropDataProvider.getWorkingTimes`.</span></span> <span data-ttu-id="e7b20-258">Užklausa yra skirta tam tikram kalendoriaus ID ir konkrečiam laiko intervalui.</span><span class="sxs-lookup"><span data-stu-id="e7b20-258">The request is for a specific calendar ID in a specific time interval.</span></span> <span data-ttu-id="e7b20-259">Atsižvelgiant į „Supply Chain Management“ serverio atmintinės būseną, kiekvienos iš šių užklausų rezultatas gali būti keli duomenų bazės kvietimai, kurie gali užtrukti (lyginant su gryno skaičiavimo laiku).</span><span class="sxs-lookup"><span data-stu-id="e7b20-259">Depending on the state of the server cache in Supply Chain Management, each of these requests could end up in several database calls, which takes a long time (relative to the pure computational time).</span></span> <span data-ttu-id="e7b20-260">Be to, jei kalendoriuje yra labai sudėtingų darbo laiko apibrėžimų, apimančių daugelį darbo laiko intervalų per dieną, tai ilgina įkėlimo laiką.</span><span class="sxs-lookup"><span data-stu-id="e7b20-260">Also, if the calendar contains very elaborate working time definitions with many working time intervals per day, this adds to the time the loading takes.</span></span>

<span data-ttu-id="e7b20-261">Kai darbo laiko duomenys įkeliami į planavimo mechanizmą, jie saugomi konkretaus kalendoriaus vidinėje atmintinėje, o tai reiškia, kad jei kitos užduotys ar ištekliai naudoja tą patį kalendorių, kitos peržvalgos gali būti atliekamos greitai naudojantis atmintimi.</span><span class="sxs-lookup"><span data-stu-id="e7b20-261">When the working time data is loaded in the scheduling engine, this is retained in its internal cache for the specific calendar, meaning that if any other jobs or resources are using the same calendar then the next lookups can be performed quickly from memory.</span></span> <span data-ttu-id="e7b20-262">Viena iš prasto efektyvumo priežasčių yra ta, kad kiekvienam ištekliui yra naudojamas atskiras kalendoriaus ID, nes tokiu atveju duomenys reikalaujami kiekvienam kalendoriui, nors kalendorių turinys gali sutapti.</span><span class="sxs-lookup"><span data-stu-id="e7b20-262">One common cause of bad performance is if a separate calendar ID is used for each resource, because data will then need to be requested for each calendar, even though the content of the calendars might be the same.</span></span>

### <a name="finite-capacity"></a><span data-ttu-id="e7b20-263">Ribotas pajėgumas</span><span class="sxs-lookup"><span data-stu-id="e7b20-263">Finite capacity</span></span>

<span data-ttu-id="e7b20-264">Esant ribotam pajėgumui, darbo laiko intervalai iš kalendoriaus yra padalijami ir sutrumpinami atsižvelgiant į esamus pajėgumų rezervavimus.</span><span class="sxs-lookup"><span data-stu-id="e7b20-264">When using finite capacity, the working time slots from the calendar are split and reduced based on the existing capacity reservations.</span></span> <span data-ttu-id="e7b20-265">Šie rezervavimai taip pat yra įkeliami naudojant tą pačią klasę `WrkCtrSchedulingInteropDataProvider`, kurią naudoja kalendoriai, tačiau šiuo atveju naudojamas metodas `getCapacityReservations`.</span><span class="sxs-lookup"><span data-stu-id="e7b20-265">These reservations are also fetched through the same `WrkCtrSchedulingInteropDataProvider` class as the calendars, but instead use the method `getCapacityReservations`.</span></span> <span data-ttu-id="e7b20-266">Atliekant planavimą bendrojo planavimo metu, nagrinėjami konkretaus bendrojo plano rezervavimai ir, jei suaktyvinta puslapyje **Bendrojo planavimo parametrai**, taip pat įtraukiami rezervavimai iš patvirtintų gamybos užsakymų.</span><span class="sxs-lookup"><span data-stu-id="e7b20-266">When scheduling during master planning, the reservations for the specific master plan are considered and if enabled on the **Master planning parameters** page, the reservations from firmed production orders are also included.</span></span> <span data-ttu-id="e7b20-267">Analogiškai, planuojant gamybos užsakymą, taip pat yra galimybė įtraukti rezervavimus iš esamų suplanuotų užsakymų, nors ši galybė nėra naudojama taip dažnai kaip priešingu atveju.</span><span class="sxs-lookup"><span data-stu-id="e7b20-267">Similarly, when scheduling a production order, it is also an option to include reservations from existing planned orders, although this is not as common as the other way around.</span></span>

<span data-ttu-id="e7b20-268">Naudojant ribotą pajėgumą, planavimas gali užtrukti ilgiau dėl kelių priežasčių:</span><span class="sxs-lookup"><span data-stu-id="e7b20-268">Using finite capacity will cause scheduling to take longer due to several reasons:</span></span>

- <span data-ttu-id="e7b20-269">Pajėgumo informacijos gavimas iš duomenų bazės yra lėta operacija, o pajėgumo informacijos saugojimas serveryje paprastai nėra toks veiksmingas kaip darbo laikų atveju, nes informacija nėra bendra skirtingiems ištekliams kaip kalendorių atveju.</span><span class="sxs-lookup"><span data-stu-id="e7b20-269">Fetching the capacity information from database is a slow operation and the server-side caching of capacity information is typically not as good as for working times because they are not shared among resources like calendars typically are.</span></span>
- <span data-ttu-id="e7b20-270">Nagrinėjamų darbo laiko intervalų skaičius auga dėl padalijimų, be to, įprastai prieš randant sprendimą turi būti nagrinėjami ilgesni laiko intervalai.</span><span class="sxs-lookup"><span data-stu-id="e7b20-270">The number of working time slots to traverse increases due to the splits, and slots for a longer time period must typically be investigated before a solution can be found.</span></span>
- <span data-ttu-id="e7b20-271">Baigus planavimą, reikia atlikti nesuderinamų rezervavimų patikrą (daugiau informacijos žr. skyriuje „Lygiagretus planavimo mechanizmų paleidimas“).</span><span class="sxs-lookup"><span data-stu-id="e7b20-271">After the scheduling is complete, a check for conflicting reservations must be performed (see the "Running scheduling engines in parallel" section for details).</span></span>

### <a name="examining-the-resource-combinations"></a><span data-ttu-id="e7b20-272">Išteklių derinių nagrinėjimas</span><span class="sxs-lookup"><span data-stu-id="e7b20-272">Examining the resource combinations</span></span>

<span data-ttu-id="e7b20-273">Jei užduoties sekoje yra tik standartiniai `FinishStart` saitai (tai reiškia, kad ji yra paprasta grandinė be šakų), optimalų rezultatą (matomas iš vieno užsakymo, ne visų užsakymų) galima pasiekti ieškant geriausio pirmosios užduoties sprendimo, o tada pereinant prie geriausio kitos užduoties sprendimo paieškos.</span><span class="sxs-lookup"><span data-stu-id="e7b20-273">If the job sequence only contains the standard `FinishStart` links, meaning it forms a simple chain without any branches, an optimal result (seen from the single order, not across orders) can be achieved by finding the best solution for the first job and then moving on to find the best solution for the next job.</span></span> <span data-ttu-id="e7b20-274">Geriausias užduoties sprendimas reiškia radimą ištekliaus, kuris gali užtikrinti užduoties pradžios ir pabaigos datą, artimiausią užduoties tikslui (vykdant tiesioginį planavimą, tai reiškia kuo ankstesnę užduoties pabaigos datą), kartu laikantis apribojimų.</span><span class="sxs-lookup"><span data-stu-id="e7b20-274">The best solution for a job means finding the resource that can get the from and to date of the job closest to the job goal (in forward scheduling this means getting the end date of the job as early as possible) while still respecting the constraints.</span></span>

<span data-ttu-id="e7b20-275">Kai yra lygiagrečių užduočių, sprendimo paieška gali apimti skirtingų išteklių derinių nagrinėjimą.</span><span class="sxs-lookup"><span data-stu-id="e7b20-275">When there are parallel jobs, finding a solution may involve examining different combinations of resources.</span></span> <span data-ttu-id="e7b20-276">Galimų išteklių derinių skaičius priklauso nup susijusių lygiagrečių užduočių galimų išteklių skaičiaus.</span><span class="sxs-lookup"><span data-stu-id="e7b20-276">The number of possible resource combinations is the product of the number of applicable resources for the connected parallel jobs.</span></span> <span data-ttu-id="e7b20-277">Ypač tada, kai atliekate atgalinį užsakymo planavimą nuo poreikio datos, gali užtrukti, kol loginė procedūra gaus rezultatą, kad nėra problemos sprendimo, kuris leistų vykdyti lygiagrečias užduotis prieš šiandienos datą, nes tam reikia patikrinti visus derinius, kadangi gali būti išteklių, kurių efektyvumas gali būti didesnis arba gali būti kitas kalendorius, kuris leistų gauti rezultatą.</span><span class="sxs-lookup"><span data-stu-id="e7b20-277">Especially when scheduling an order backwards from a requirement date, it can take quite a while for the logic to realize that there is no solution to the problem that will make the parallel jobs fit before today's date, as it will need to check all the combinations because there could be some resources that had a higher efficiency or a different calendar that might give a result.</span></span> <span data-ttu-id="e7b20-278">Tai reiškia, kad, jei nebuvo nustatyta skirtojo laiko riba, planavimas bus vykdomas ilgą laiką, kol kryptis bus pakeista į tiesioginę.</span><span class="sxs-lookup"><span data-stu-id="e7b20-278">This means that if no timeout limit has been set it will run for a long time before changing the direction to forward.</span></span>

<span data-ttu-id="e7b20-279">Ši kombinatorinė logika taip pat reiškia, kad pridėjus daugiau taikytinų išteklių mechanizmas gali veikti lėčiau.</span><span class="sxs-lookup"><span data-stu-id="e7b20-279">This combinatorial logic also means that adding more applicable resources may make the engine run slower.</span></span> <span data-ttu-id="e7b20-280">Jei efektyvumo problemų kyla vykdant lygiagrečias operacijas ir atliekant planavimą su neribotais pajėgumais, jas galima iš dalies išspręsti leidžiant maršruto sudarymo įrankiui priimti sprendimą, kuris išteklius turi būti naudojamas, o tada priskirti išteklių tiesiogiai operacijai (nes daugeliu atvejų mechanizmas galiausiai pasirinks tą patį išteklių, todėl galutinis rezultatas bus toks pats).</span><span class="sxs-lookup"><span data-stu-id="e7b20-280">If performance problems occur when having parallel operations and scheduling with infinite capacity, it can partly be fixed by having the route designer take a decision on which resource should be used and then assign the resource directly on the operation (because the engine in most cases will always end up picking the same resource, so the end result will be the same).</span></span>

### <a name="hard-links"></a><span data-ttu-id="e7b20-281">Kietieji saitai</span><span class="sxs-lookup"><span data-stu-id="e7b20-281">Hard links</span></span>

<span data-ttu-id="e7b20-282">Nustačius dviejų užduočių saitą kaip kietąjį, užtikrinama, kad nebūtų laiko intervalo tarp vienos užduoties pabaigos ir kitos darbo pradžios.</span><span class="sxs-lookup"><span data-stu-id="e7b20-282">Setting the link type between two jobs to hard, ensures that there is no time gap between the finish of one job and the start of the next one.</span></span> <span data-ttu-id="e7b20-283">Tai gali būti labai naudinga, pavyzdžiui, kai metalas yra kaitinamas atliekant vieną užduotį, o tada yra apdorojamas atliekant kitą užduotį ir nėra pageidaujama, kad metalas atvėstų.</span><span class="sxs-lookup"><span data-stu-id="e7b20-283">This can be very useful in scenarios like when metal is heated in one job and then processed in the next job, where it is not desirable to have the metal cool down in between.</span></span>

<span data-ttu-id="e7b20-284">Naudojant standartinius minkštuosius saitus ir tiesioginį planavimą, jei maršrutas sudaro paprastą grandinę be šakų, rezultatą galima pasiekti ieškant pirmosios užduoties sprendimo, kuris atitiktų apribojimus, o tada keliaujant grandine ir perduodant pabaigos laiką iš ankstesnės užduoties į kitą užduotį.</span><span class="sxs-lookup"><span data-stu-id="e7b20-284">With standard soft links and forward scheduling, if the route forms a simple chain without any branches, a result can be achieved by finding a solution for the first job that satisfies its own constraints and then moving on through the chain propagating the end time from the previous job to the next job.</span></span> <span data-ttu-id="e7b20-285">Jei dabartinei užduočiai nepavyksta rasti pajėgumo, jos pradžios laikas bus perkeliamas toliau, tačiau tai neturės įtakos ankstesnėms užduotims, todėl gali atsirasti tarpų tarp užduočių.</span><span class="sxs-lookup"><span data-stu-id="e7b20-285">If the current job can't find any capacity, the start time for it will be moved out further, without any consequence for the previous jobs potentially creating gaps between the jobs.</span></span> <span data-ttu-id="e7b20-286">Tačiau tam pačiam scenarijui naudojant kietuosius saitus (ypač bendrai su ribotu pajėgumu), tai, kad vienai užduočiai grandinėje nepavyksta rasti pajėgumo, reiškia, kad visos prieš tai suplanuotos užduotys turi būti perkeltos po vieną ir pakartotinis planavimas bus atliekamas kelis kartus.</span><span class="sxs-lookup"><span data-stu-id="e7b20-286">However with hard links (especially in connection with finite capacity) for the same scenario, the fact that one job later in the chain cannot find capacity, will mean that all previous scheduled jobs will have to be "dragged" along one by one and thereby rescheduled a number of times.</span></span> <span data-ttu-id="e7b20-287">Ypač tais atvejais, kai kelių išteklių apkrova yra didelė, dėl kietųjų saitų gali įvykti grandininė reakcija, kurios metu užduotys darys poveikį viena kitai ir reikės atlikti keletą iteracijų, kol rezultatas stabilizuosis ir bus gautas patenkinamas grafikas.</span><span class="sxs-lookup"><span data-stu-id="e7b20-287">Especially in scenarios with high load for multiple resources, the hard links can cause a chain reaction where the jobs will affect each other and a number of iterations will have to be performed before the result stabilizes into a feasible schedule.</span></span>

## <a name="running-scheduling-engines-in-parallel"></a><span data-ttu-id="e7b20-288">Lygiagretus planavimo mechanizmų paleidimas</span><span class="sxs-lookup"><span data-stu-id="e7b20-288">Running scheduling engines in parallel</span></span>

<span data-ttu-id="e7b20-289">Kai planavimas yra atliekamas kaip bendrojo planavimo dalis, kuriai naudojami pagalbiniai įrankiai, kiekviena bendrojo planavimo pagalbinio įrankio gija taip pat gali perimti gamybos užsakymo planavimo užduotis.</span><span class="sxs-lookup"><span data-stu-id="e7b20-289">When performing scheduling as part of a master planning run where helpers are used, each of the master planning helper threads can also pick up production order scheduling tasks.</span></span> <span data-ttu-id="e7b20-290">Tai reiškia, kad vienu metu galima paleisti kelis planavimo mechanizmus.</span><span class="sxs-lookup"><span data-stu-id="e7b20-290">This means that multiple scheduling engines can be running at the same time.</span></span> <span data-ttu-id="e7b20-291">Nors kelių gijų režimas apskritai labai padeda padidinti efektyvumą, yra tam tikrų funkcinių trūkumų planavimo požiūriu.</span><span class="sxs-lookup"><span data-stu-id="e7b20-291">While multithreading in general is a highly significant performance benefit, there are also some functional downsides when it comes to scheduling.</span></span>

<span data-ttu-id="e7b20-292">Vykdant MRP, visi duotos komplektavimo specifikacijos (KS) lygio gamybos užsakymai yra planuojami pagal poreikio datų seką, t. y. tie užsakymai, kurių poreikio data yra anksčiausia, turi būti suplanuoti pirmiausia ir tokiu būdu turėti didžiausią galimybę gauti atitinkamą ištekliaus pajėgumą.</span><span class="sxs-lookup"><span data-stu-id="e7b20-292">In MRP, all production orders for a given bill of materials (BOM) level are scheduled in requirement date sequence, meaning that those orders with the earliest requirement date should be scheduled first and thereby have the highest chance of getting the available resource capacity.</span></span> <span data-ttu-id="e7b20-293">Tačiau tada, kai keli mechanizmai vykdo atranką iš nesuplanuotų užsakymų sąrašo, sekos nebegalima užtikrinti, nes vienas mechanizmas darbą gali baigti greičiau už kitą.</span><span class="sxs-lookup"><span data-stu-id="e7b20-293">However, with multiple engines picking from the list of unscheduled orders the sequence is no longer ensured, as one might complete faster than the other.</span></span>

<span data-ttu-id="e7b20-294">Be to, kai planavimas atliekamas naudojant ribotą pajėgumą ir kai keli mechanizmo egzemplioriai bando suplanuoti užsakymus, kurie potencialiai gali naudoti tuos pačius išteklius tą patį laikotarpį, gali prasidėti konkuravimas.</span><span class="sxs-lookup"><span data-stu-id="e7b20-294">Also, when scheduling using finite capacity and when multiple engine instances are trying to schedule orders that are potentially using the same resources at the same time interval, a race condition can occur.</span></span> <span data-ttu-id="e7b20-295">Tokių konkuravimo sąlygų skaičius rodomas lauke **Planavimo konfliktai**, kuris yra bendrojo planavimo retrospektyvos puslapyje.</span><span class="sxs-lookup"><span data-stu-id="e7b20-295">The number of such race conditions is recorded in the **Scheduling conflicts** field on the master plans history page.</span></span> <span data-ttu-id="e7b20-296">Konfliktų sprendimo logika yra tokia:</span><span class="sxs-lookup"><span data-stu-id="e7b20-296">The conflict resolution logic is as follows:</span></span>

- <span data-ttu-id="e7b20-297">Suplanuokite užsakymą (be blokavimo) ir gaukite pajėgumo rezervavimus.</span><span class="sxs-lookup"><span data-stu-id="e7b20-297">Schedule an order (lock-free) and get capacity reservations.</span></span>
- <span data-ttu-id="e7b20-298">Užblokuokite.</span><span class="sxs-lookup"><span data-stu-id="e7b20-298">Take the lock.</span></span>
- <span data-ttu-id="e7b20-299">Patikrinkite, ar suplanuotiems ištekliams laiko intervale yra naujesnių pajėgumo rezervavimų.</span><span class="sxs-lookup"><span data-stu-id="e7b20-299">Check if newer capacity reservations exist for the scheduled resources in the timespan.</span></span>
  - <span data-ttu-id="e7b20-300">Jei ne, įrašykite pajėgumą ir atblokuokite.</span><span class="sxs-lookup"><span data-stu-id="e7b20-300">If no, write the capacity and release the lock.</span></span>
  - <span data-ttu-id="e7b20-301">Jei taip, atblokuokite ir perplanuokite užsakymą nuo pradžių.</span><span class="sxs-lookup"><span data-stu-id="e7b20-301">If yes, release the lock and reschedule the order from the beginning.</span></span>

<span data-ttu-id="e7b20-302">Todėl, kai planavimas atliekamas kelis mechanizmo egzempliorius, rezultatas nėra visiškai apibrėžtas, nes jis priklausys nuo to, kaip veikia gijos.</span><span class="sxs-lookup"><span data-stu-id="e7b20-302">So, when scheduling with multiple engine instances, the result is not fully deterministic because it will depend on the exact timing of each of the threads.</span></span>

## <a name="operation-scheduling-performance"></a><span data-ttu-id="e7b20-303">Operacijų planavimo efektyvumas</span><span class="sxs-lookup"><span data-stu-id="e7b20-303">Operation scheduling performance</span></span>

<span data-ttu-id="e7b20-304">Nors operacijų planavimas yra žinomas kaip apytikslis pajėgumų planavimas, mechanizmo požiūriu, tai gali būti sunkiau išsprendžiama problema, jei naudojamas ribotas pajėgumas, nes šiuo atveju tinkamumui įvertinti reikia daugiau duomenų.</span><span class="sxs-lookup"><span data-stu-id="e7b20-304">Even though operation scheduling is also known as rough-cut capacity planning, seen from an engine standpoint, it can be a harder problem to solve if finite capacity is used, as more data is needed to determine feasibility.</span></span>

<span data-ttu-id="e7b20-305">Išteklių grupės pajėgumas priklauso nuo to, kokių ir kiek išteklių yra išteklių grupės nariai.</span><span class="sxs-lookup"><span data-stu-id="e7b20-305">The capacity of a resource group depends on which and how many resources are members of the resource group.</span></span> <span data-ttu-id="e7b20-306">Pati išteklių grupė neturi pajėgumo &mdash; tik tada, kai grupei priklauso ištekliai, ji turės pajėgumą.</span><span class="sxs-lookup"><span data-stu-id="e7b20-306">A resource group in itself does not have any capacity&mdash;only when resources are a member of the group will it have capacity.</span></span> <span data-ttu-id="e7b20-307">Kadangi priklausymas išteklių grupei laikui bėgant gali kisti, turi būti vertinamas dienos pajėgumas.</span><span class="sxs-lookup"><span data-stu-id="e7b20-307">Because the resource group membership can vary over time, capacity must be evaluated per day.</span></span>

<span data-ttu-id="e7b20-308">Operacijų planavimo metu išteklių grupės kalendorius naudojamas nustatyti kiekvienos operacijos pradžios ir pabaigos laikus.</span><span class="sxs-lookup"><span data-stu-id="e7b20-308">In operations scheduling, the resource group's calendar is used to determine the start and end times for each operation.</span></span> <span data-ttu-id="e7b20-309">Tai reiškia, kad išteklių grupės kalendoriuje yra riba, kiek laiko vieną dieną gali būti suplanuota vienai operacijai vienoje išteklių grupėje.</span><span class="sxs-lookup"><span data-stu-id="e7b20-309">This means that the resource group's calendar places a limit on how much time can be operations scheduled for one operation on one day in one resource group.</span></span> <span data-ttu-id="e7b20-310">Skirtingai nuo konkrečių išteklių kalendoriaus, išteklių grupei nepaisoma kalendoriaus efektyvumo duomenų, nes jie paprasčiausiai atitinka darbo pradžios valandas, o ne faktinį pajėgumą.</span><span class="sxs-lookup"><span data-stu-id="e7b20-310">Opposite the calendar for the specific resources, the efficiency data of the calendar is ignored for the resource group as it simply denotes opening hours and not actual capacity.</span></span>

<span data-ttu-id="e7b20-311">Pavyzdžiui, jei išteklių grupės darbo laikas tam tikrą dieną yra nuo 8:00 iki 16:00 valandos, vienos operacijos apkrova išteklių grupei negali būti didesnė nei 8 valandos, nepriklausomai nuo to, koks bendras išteklių grupės pajėgumas yra tą dieną.</span><span class="sxs-lookup"><span data-stu-id="e7b20-311">For example, if the working time for a resource group on one specific date is from 8:00 to 16:00, one operation can't put more load on the resource group than what can be fit into 8 hours, no matter how much capacity that the resource group has available in total on that day.</span></span> <span data-ttu-id="e7b20-312">Tačiau apkrovą gali dar labiau apriboti pasiekiamas pajėgumas.</span><span class="sxs-lookup"><span data-stu-id="e7b20-312">The available capacity can however limit the load further.</span></span>

<span data-ttu-id="e7b20-313">Skaičiuojant galimą tos pačios dienos išteklių grupės pajėgumą, vertinama visų išteklių, priklausančių išteklių grupei, užduoties planavimo apkrova duotą dieną.</span><span class="sxs-lookup"><span data-stu-id="e7b20-313">The load from job scheduling on all the resources included in the resource group on a given day is considered when the available capacity for the resource group on the same day is calculated.</span></span> <span data-ttu-id="e7b20-314">Kiekvienai dienai skaičiavimas atliekamas taip:</span><span class="sxs-lookup"><span data-stu-id="e7b20-314">For each date, the calculation is:</span></span>

> <span data-ttu-id="e7b20-315">Galimas išteklių grupės pajėgumas =</span><span class="sxs-lookup"><span data-stu-id="e7b20-315">Available resource group capacity =</span></span>  
> <span data-ttu-id="e7b20-316">(pajėgumas grupės ištekliams remiantis kalendoriumi) -</span><span class="sxs-lookup"><span data-stu-id="e7b20-316">(capacity for resources in the group based on their calendar) -</span></span>  
> <span data-ttu-id="e7b20-317">(suplanuotos užduoties apkrova grupės ištekliams) -</span><span class="sxs-lookup"><span data-stu-id="e7b20-317">(job scheduled load on the resources in the group) -</span></span>  
> <span data-ttu-id="e7b20-318">(suplanuotų operacijų apkrova grupės ištekliams) -</span><span class="sxs-lookup"><span data-stu-id="e7b20-318">(operations scheduled load on the resources in the group) -</span></span>  
> <span data-ttu-id="e7b20-319">(suplanuotų operacijų apkrova išteklių grupei) -</span><span class="sxs-lookup"><span data-stu-id="e7b20-319">(operations scheduled load on the resource group)</span></span>

<span data-ttu-id="e7b20-320">Skirtuke **Išteklių reikalavimai** maršruto operacijai galima nurodyti išteklių reikalavimus. Tam galima naudoti konkretų išteklių (tokiu atveju operacija bus planuojama naudojant šį išteklių), išteklių grupę, ištekliaus tipą arba vieną ar kelias galimybes, įgūdžius, kursą ar sertifikatą.</span><span class="sxs-lookup"><span data-stu-id="e7b20-320">On the **Resource requirements** tab on the route operation, the resource requirements can be specified using either a specific resource (in which case the operation will be scheduled using that resource), for a resource group, for a resource type, or for one or more capabilities, skill, course, or certificate.</span></span> <span data-ttu-id="e7b20-321">Nors naudojant visas šias pasirinktis maršruto kūrimas tampa lankstesnis, tai taip pat apsunkina planavimą mechanizmui, nes pajėgumas turi būti vertinamas pagal „ypatybę“ (abstraktus pavadinimas, mechanizme naudojamas galimybėms, įgūdžiams ir pan.).</span><span class="sxs-lookup"><span data-stu-id="e7b20-321">While using all of these options gives a great flexibility on the route design, it also complicates the scheduling for the engine as the capacity must be accounted for per "property" (the abstract name used in the engine for capability, skills, and so on).</span></span>

<span data-ttu-id="e7b20-322">Išteklių grupės galimybės pajėgumas yra visų išteklių grupės išteklių, apimančių atitinkamą galimybę, pajėgumo suma.</span><span class="sxs-lookup"><span data-stu-id="e7b20-322">The resource group's capacity for a capability is the sum of the capacity for all resources in the resource group that has the capability in question.</span></span> <span data-ttu-id="e7b20-323">Jei grupės išteklius turi galimybę, ji bus įskaičiuojama neatsižvelgiant į tai, kokio lygio pajėgumo reikia.</span><span class="sxs-lookup"><span data-stu-id="e7b20-323">If a resource in the group has a capability, it will be considered no matter what level of the capacity is required.</span></span>

<span data-ttu-id="e7b20-324">Atliekant operacijų planavimą, galimas išteklių grupės tam tikros galimybės pajėgumas bus sumažintas, kai ji įkeliama su operacija, kuriai reikia atitinkamos galimybės.</span><span class="sxs-lookup"><span data-stu-id="e7b20-324">In operations scheduling, the available capacity for a certain capability for a resource group will be reduced when it is loaded with an operation that requires the capability in question.</span></span> <span data-ttu-id="e7b20-325">Jei operacijai reikalinga daugiau nei viena galimybė, pajėgumas bus sumažintas visoms reikalingoms galimybėms.</span><span class="sxs-lookup"><span data-stu-id="e7b20-325">If the operation requires more than one capability, the capacity will be reduced for all required capabilities.</span></span>

<span data-ttu-id="e7b20-326">Kiekvienai dienai reikalingas skaičiavimas atliekamas taip:</span><span class="sxs-lookup"><span data-stu-id="e7b20-326">For each date, the required calculation is:</span></span>

> <span data-ttu-id="e7b20-327">Galimas galimybės pajėgumas =</span><span class="sxs-lookup"><span data-stu-id="e7b20-327">The available capacity for a capability =</span></span>  
> <span data-ttu-id="e7b20-328">(galimybės pajėgumas) -</span><span class="sxs-lookup"><span data-stu-id="e7b20-328">(the capacity for the capability) -</span></span>  
> <span data-ttu-id="e7b20-329">(suplanuotos užduoties apkrova ištekliams, įtrauktiems į išteklių grupę, su tam tikra galimybe) -</span><span class="sxs-lookup"><span data-stu-id="e7b20-329">(job scheduled load on the resources with the specific capability, included in the resource group) -</span></span>  
> <span data-ttu-id="e7b20-330">(suplanuotos operacijos apkrova ištekliams, įtrauktiems į išteklių grupę, su tam tikra galimybe) -</span><span class="sxs-lookup"><span data-stu-id="e7b20-330">(operations scheduled load on the resources with the specific capability, included in the resource group) -</span></span>  
> <span data-ttu-id="e7b20-331">(suplanuotos operacijos apkrova išteklių grupei, kuriai reikia tam tikros galimybės)</span><span class="sxs-lookup"><span data-stu-id="e7b20-331">(operations scheduled load on the resource group itself that require the specific capability)</span></span>

<span data-ttu-id="e7b20-332">Tai reiškia, kad, jei yra tam tikro ištekliaus apkrova, apkrova įtraukiama į išteklių grupės galimo pajėgumo pagal galimybę skaičiavimą, nes tam tikro ištekliaus apkrova sumažina įnašą į išteklių grupės pajėgumą pagal galimybę, neatsižvelgiant į tai, ar tam tikro ištekliaus apkrova yra susijusi su konkrečia galimybe.</span><span class="sxs-lookup"><span data-stu-id="e7b20-332">This means that if there is load on a specific resource, the load is considered in the calculation of the resource group's available capacity per capability, because the load on a specific resource reduces its contribution to the resource group's capacity for a capability no matter if the load on the specific resource is for that specific capability.</span></span> <span data-ttu-id="e7b20-333">Jei apkrova yra išteklių grupės lygyje, ji yra įtraukiama į išteklių grupės galimo pajėgumo pagal galimybę skaičiavimą tik tada, kai apkrova kyla iš operacijos, kuriai reikia konkrečios galimybės.</span><span class="sxs-lookup"><span data-stu-id="e7b20-333">If there is load on the resource group level, it is considered in the calculation of the resource group's available capacity per capability only if the load is from an operation that requires the specific capability.</span></span>

<span data-ttu-id="e7b20-334">Prieš tai aprašyta logika yra komplikuota, nes ji yra tokia pati kiekvienam „ypatybės“ tipui ir todėl vykdant operacijų planavimą su ribotais pajėgumais reikia įkelti didelį kiekį duomenų.</span><span class="sxs-lookup"><span data-stu-id="e7b20-334">The above logic is complicatd, as this is the same for each type of "property" so using operations scheduling with finite capacity requires a significant amount of data to be loaded.</span></span>

## <a name="viewing-scheduling-engine-input-and-output"></a><span data-ttu-id="e7b20-335">Planavimo mechanizmo įvesties ir išvesties peržiūra</span><span class="sxs-lookup"><span data-stu-id="e7b20-335">Viewing scheduling engine input and output</span></span>

<span data-ttu-id="e7b20-336">Norėdami gauti tam tikrą informaciją apie planavimo proceso įvestį ir išvestį, įjunkite registravimą nueidami į **Organizacijos administravimas \> Sąranka \> Planavimas \> Planavimo sekimo centras**.</span><span class="sxs-lookup"><span data-stu-id="e7b20-336">To get specific details of the input and output of the scheduling process,  enable logging by going to **Organization administration \> Setup \> Scheduling \> Scheduling tracing cockpit**.</span></span>

<span data-ttu-id="e7b20-337">Šiame puslapyje, veiksmų srityje pirmiausia pasirinkite **Įjungti registravimą**.</span><span class="sxs-lookup"><span data-stu-id="e7b20-337">On this page, first select **Enable logging** on the Action Pane.</span></span> <span data-ttu-id="e7b20-338">Tada paleiskite gamybos užsakymo planavimą.</span><span class="sxs-lookup"><span data-stu-id="e7b20-338">Then run the scheduling for the production order.</span></span> <span data-ttu-id="e7b20-339">Baigus, sugrįžkite į puslapį **Planavimo sekimo centras** ir veiksmų srityje pasirinkite **Išjungti registravimą**.</span><span class="sxs-lookup"><span data-stu-id="e7b20-339">When complete, return to the **Scheduling tracing cockpit** page and select **Disable logging** on the Action Pane.</span></span> <span data-ttu-id="e7b20-340">Atnaujinkite puslapį ir tinklelyje bus rodoma nauja eilutė.</span><span class="sxs-lookup"><span data-stu-id="e7b20-340">Refresh the page and a new line will appear in the grid.</span></span> <span data-ttu-id="e7b20-341">Pasirinkite naują eilutę ir veiksmų srityje pasirinkite **Atsisiųsti**.</span><span class="sxs-lookup"><span data-stu-id="e7b20-341">Select the new line and select **Download** on the Action Pane.</span></span> <span data-ttu-id="e7b20-342">Tada gausite suglaudintą .zip aplanką su šiais failais:</span><span class="sxs-lookup"><span data-stu-id="e7b20-342">This will give you a .zip compressed folder containing the following files:</span></span>

- <span data-ttu-id="e7b20-343">**Log.txt** – tai žurnalo failas, kuriame aprašomi veiksmai, kuriuos atlieka mechanizmas.</span><span class="sxs-lookup"><span data-stu-id="e7b20-343">**Log.txt** - This is the log file that describes the steps that the engine goes through.</span></span> <span data-ttu-id="e7b20-344">Nors jis yra sudėtingas ir gali būti didelės apimties, tačiau, kai eksperimentuojate su maršruto sąranka, norėdami išspręsti efektyvumo problemas, pirmiausia pasižiūrėkite į laiko skirtumą tarp pirmosios ir paskutinės eilučių, nes tokiu būdu galėsite sužinoti tikslų laiką, kurį dirbo planuoklė.</span><span class="sxs-lookup"><span data-stu-id="e7b20-344">It is very elaborate and can be a bit overwhelming, but when used as part of experimenting with the route setup to resolve performance problems the first thing to look for is the difference in time between the first and the last line, as this will give you the exact time the scheduler has spent.</span></span>
- <span data-ttu-id="e7b20-345">**XmlModel.xml** – jame yra modelis, sukurtas naudojant X++, kuriuo remiasi mechanizmas.</span><span class="sxs-lookup"><span data-stu-id="e7b20-345">**XmlModel.xml** - This contains the model that is built in X++ and that the engine operates on.</span></span> <span data-ttu-id="e7b20-346">Faile naudojamas `JobId` yra susijęs su `RecId` iš šaltinio lentelės, kurioje yra užduotys ( `ReqRouteJob` arba `ProdRouteJob`).</span><span class="sxs-lookup"><span data-stu-id="e7b20-346">The `JobId` used in the file correlates to the `RecId` from the source table containing the jobs (`ReqRouteJob` or `ProdRouteJob`).</span></span> <span data-ttu-id="e7b20-347">Šiame faile patikrinkite, ar datos, nurodytos `ConstraintJobStartsAt` ir `ConstraintJobEndsAt`, yra tokios, kokių laukiama, ar `JobGoal` ypatybė yra tinkamai nustatyta ir ar užduotys yra tarpusavyje susietos `JobLink` apribojimais.</span><span class="sxs-lookup"><span data-stu-id="e7b20-347">The typical thing to look for in this file is that the dates given in `ConstraintJobStartsAt` and `ConstraintJobEndsAt` are as expected, that the `JobGoal` property is set correctly, and that the jobs are related to each other through the `JobLink` constraints.</span></span>
- <span data-ttu-id="e7b20-348">**XmlSlots.xml** – jame yra visi darbo laikai ir pajėgumo rezervavimai, kurių reikalavo variklis.</span><span class="sxs-lookup"><span data-stu-id="e7b20-348">**XmlSlots.xml** - This contains all the working times and capacity reservations that the engine has requested.</span></span> <span data-ttu-id="e7b20-349">Mechanizmas reikalaus kalendoriaus darbo laikų ir rezervavimų tik laikotarpiams, kuriems mėgina planuoti užduotis (kartu su papildomu buferiu), todėl jei į failą yra įtraukti toli į ateitį nutolę laikai, tai gali reikšti sąrankos problemą.</span><span class="sxs-lookup"><span data-stu-id="e7b20-349">The calendar working times and reservations will only be requested by the engine for the time periods where it tries to place the jobs (and an extra buffer), so if the file contains times very far in the future, it might be an indication of a problem with the setup.</span></span> <span data-ttu-id="e7b20-350">Kiekvienam ištekliui `ResourceProperty` mazguose bus matoma, su kokiomis ištekių grupėmis ir galimybėmis bei kuriais laikotarpiais jis yra susijęs.</span><span class="sxs-lookup"><span data-stu-id="e7b20-350">The `ResourceProperty` nodes will show for each resource which resource group and capabilities it is associated with for which periods.</span></span>
- <span data-ttu-id="e7b20-351">**Result.xml** – jame yra planavimo procedūros rezultatas.</span><span class="sxs-lookup"><span data-stu-id="e7b20-351">**Result.xml** - This contains the result of the scheduling run.</span></span>

<span data-ttu-id="e7b20-352">Atkreipkite dėmesį, kad sekimo funkcija gali žymiai padidinti apkrovą, todėl ją naudokite tik nagrinėti konkrečių užsakymų planavimui kontroliuojamomis aplinkybėmis.</span><span class="sxs-lookup"><span data-stu-id="e7b20-352">Note that the tracing functionality can add significant performance overhead, so only use it for investigating scheduling of specific orders in a controlled manner.</span></span> <span data-ttu-id="e7b20-353">Jei ji įjungta atliekant bendrąjį planavimą, ji greitai pasieks dydžio ribą ir sustos.</span><span class="sxs-lookup"><span data-stu-id="e7b20-353">If it is turned on during a master planning run it will quickly reach its size limit and stop.</span></span>

## <a name="troubleshooting-performance"></a><span data-ttu-id="e7b20-354">Efektyvumo trikčių šalinimas</span><span class="sxs-lookup"><span data-stu-id="e7b20-354">Troubleshooting performance</span></span>

<span data-ttu-id="e7b20-355">Kaip galima suprasti iš visų prieš tai esančių skyrių, kalbant apie sąranką ir planavimo mechanizmo naudojimą, yra tam tikrų aplinkybių, kurios gali lemti efektyvumo problemas.</span><span class="sxs-lookup"><span data-stu-id="e7b20-355">As can be understood from all of the previous sections, there are some pitfalls when it comes to the setup and usage of the scheduling engine, which can lead to performance problems.</span></span> <span data-ttu-id="e7b20-356">Sprendžiant tokias problemas galima naudoti toliau pateiktą kontrolinį sąrašą.</span><span class="sxs-lookup"><span data-stu-id="e7b20-356">The following check list can be used for troubleshooting such issues.</span></span> <span data-ttu-id="e7b20-357">Svarbu įvertinti visus punktus, nes dažniausiai problemų kyla dėl įvairių veiksnių derinio.</span><span class="sxs-lookup"><span data-stu-id="e7b20-357">It is important to look at all the points as it is most often a combination of multiple factors that leads to problems.</span></span>

### <a name="performing-scheduling-as-part-of-mrp-when-it-is-not-needed"></a><span data-ttu-id="e7b20-358">Planavimas vykdomas kaip MRP dalis, kai tai nėra būtina</span><span class="sxs-lookup"><span data-stu-id="e7b20-358">Performing scheduling as part of MRP when it is not needed</span></span>

<span data-ttu-id="e7b20-359">Nepaisant to, kad maršrutai naudojami gamybos kontrolės tikslais, pvz., įkainojimui ir ataskaitoms, jie gali būti nebūtini vykdant MRP.</span><span class="sxs-lookup"><span data-stu-id="e7b20-359">Even though routes are used for the production control purposes such as costing and reporting, it might not be necessary to consider them during MRP.</span></span> <span data-ttu-id="e7b20-360">Kai kuriais atvejais planavimui gali pakakti prekei nurodyto standartinio gamybos vykdymo laiko.</span><span class="sxs-lookup"><span data-stu-id="e7b20-360">In some cases, having a standard production lead time specified for the item will be sufficient for planning.</span></span> <span data-ttu-id="e7b20-361">Norėdami išjungti maršruto planavimą, nustatykite nulinę pajėgumo laiko ribą.</span><span class="sxs-lookup"><span data-stu-id="e7b20-361">To turn off route scheduling, set the capacity time fence to zero.</span></span> <span data-ttu-id="e7b20-362">Jei planavimą reikia vykdyti, pajėgumo laiko ribą reikia nustatyti atsargiai, nes gali būti nebūtina įvertinti maršrutų taikant visos MRP apimties laiko ribą.</span><span class="sxs-lookup"><span data-stu-id="e7b20-362">If scheduling should be done, then the capacity time fence must be carefully set because it might not be necessary to consider routes for the full extent of the MRP's coverage time fence.</span></span>

<span data-ttu-id="e7b20-363">Atkreipkite dėmesį, kad jei užsakymas nėra suplanuotas MRP, jį reikės suplanuoti suplanuoto užsakymo patvirtinimo metu.</span><span class="sxs-lookup"><span data-stu-id="e7b20-363">Note that if the order is not scheduled during MRP, then it will instead need to be scheduled when the planned order is firmed.</span></span> <span data-ttu-id="e7b20-364">Tai reiškia, kad patvirtinimo procesas užtruks ilgiau, todėl, atsižvelgiant į tai, kiek siūlomų suplanuotų užsakymų yra patvirtinami, nauda dėl didesnio MRP efektyvumo gali būti prarasta patvirtinimo metu.</span><span class="sxs-lookup"><span data-stu-id="e7b20-364">This means that the firming process will take longer, so depending on how many of the suggested planned orders get firmed the performance gain during MRP might be lost at firming.</span></span>

### <a name="route-with-unnecessary-operations"></a><span data-ttu-id="e7b20-365">Maršrutas su nereikalingomis operacijomis</span><span class="sxs-lookup"><span data-stu-id="e7b20-365">Route with unnecessary operations</span></span>

<span data-ttu-id="e7b20-366">Kuriant maršrutą, gali kilti noras bandyti modeliuoti realų pasaulį su visais gamybos proceso veiksmais.</span><span class="sxs-lookup"><span data-stu-id="e7b20-366">When designing the route, it is tempting to try to model the real world exactly with all the steps the production goes through.</span></span> <span data-ttu-id="e7b20-367">Nors tai gali būti naudinga kai kuriais atvejais, tai nėra gerai efektyvumo požiūriu, nes modelis, su kuriuo turi dirbti mechanizmas tampa didesnis (užduočių ir apribojimų požiūrių), be to, atliekant užduočių ir pajėgumų rezervavimų įterpimą bei atnaujinimą bus vykdoma daugiau SQL sakinių.</span><span class="sxs-lookup"><span data-stu-id="e7b20-367">While this can be useful in some cases, it is not good for the performance as the model the engine needs to work on gets larger (both in terms of jobs and constraints) and more SQL statements will be executed for insertion and update of the jobs and capacity reservations.</span></span> <span data-ttu-id="e7b20-368">Be to, tai turi poveikį galiausiai pateikiant atskaitas apie užduočių eigą, kurį galima sumažinti naudojant automatinį skelbimą.</span><span class="sxs-lookup"><span data-stu-id="e7b20-368">Also, there is the downstream effect of having to eventually report progress on the jobs, which can be mitigated with automatic postings.</span></span> <span data-ttu-id="e7b20-369">Jei duomenys nėra naudojami iš viso, sukuriama nereikalinga apkrova.</span><span class="sxs-lookup"><span data-stu-id="e7b20-369">If the data is not used for anything, it creates unnecessary load.</span></span>

<span data-ttu-id="e7b20-370">Rekomenduojame sukurti tik tokias operacijas, kurių būtinai reikia planavimui (paprastai tai yra ribojantys ištekliai) ir (arba) įkainojimui.</span><span class="sxs-lookup"><span data-stu-id="e7b20-370">We recommend that you only create operations that are strictly needed for scheduling (which will typically be the bottleneck resources) and/or costing purposes.</span></span> <span data-ttu-id="e7b20-371">Arba sugrupuokite daug mažesnių atskirų operacijų į vieną didesnę operaciją, kuri atitinka didesnę proceso dalį.</span><span class="sxs-lookup"><span data-stu-id="e7b20-371">Alternatively you should group many smaller distinct operations into one larger operation that represents a greater part of the process.</span></span>

### <a name="many-applicable-resources-for-an-operation"></a><span data-ttu-id="e7b20-372">Operacija su daugeliu galimų išteklių</span><span class="sxs-lookup"><span data-stu-id="e7b20-372">Many applicable resources for an operation</span></span>

<span data-ttu-id="e7b20-373">Galimų operacijos išteklių skaičius nustatomas pagal išteklių reikalavimus, nurodytus operacijos ryšyje.</span><span class="sxs-lookup"><span data-stu-id="e7b20-373">The number of applicable resources for an operation is determined by the resource requirements set on the operation relation.</span></span> <span data-ttu-id="e7b20-374">Reikalavimas gali būti taikomas konkrečiam (atskiram) ištekliui arba jis gali būti pagrįstas ištekliaus priklausomumu išteklių grupei arba galimybei.</span><span class="sxs-lookup"><span data-stu-id="e7b20-374">The requirement can either be for a specific (individual) resource or it can be based on the resource's membership of a resource group or capability.</span></span>

<span data-ttu-id="e7b20-375">Jei planavimas nėra atliekamas naudojant ribotą pajėgumą ir visi galimi ištekliai turi tą patį kalendorių ir pasižymi tuo pačiu efektyvumu, planavimo mechanizmas visada operacijai parinks tą patį išteklių, tačiau tik tada, kai prieš tai išbandys visus galimus išteklius, kad patikrintų, ar nėra geresnio.</span><span class="sxs-lookup"><span data-stu-id="e7b20-375">If scheduling is not done using finite capacity and all the applicable resources have the same calendar and efficiency, then the scheduling engine will always end up picking the same resource for an operation, but only after trying all the applicable resources to check if there is one that is "better" than the others.</span></span> <span data-ttu-id="e7b20-376">Tokiu atveju planavimo apkrovą galima žymiai sumažinti operacijai visada priskiriant tam tikrą išteklių maršruto kūrimo metu.</span><span class="sxs-lookup"><span data-stu-id="e7b20-376">In this case, the load of the scheduling can be greatly reduced simply by always assigning a specific resource to the operation at the route design time.</span></span>

### <a name="route-with-parallel-operations"></a><span data-ttu-id="e7b20-377">Maršrutas su lygiagrečiomis operacijomis</span><span class="sxs-lookup"><span data-stu-id="e7b20-377">Route with parallel operations</span></span>

<span data-ttu-id="e7b20-378">Lygiagrečios operacijos (pirminės / antrinės) yra galingas įrankis, kurį galima naudoti modeliuoti scenarijams, kai, pavyzdžiui, įrenginys ir operatorius yra būtini tam tikrai užduočiai atlikti, tačiau jos taip pat yra daugelio efektyvumo problemų priežastis.</span><span class="sxs-lookup"><span data-stu-id="e7b20-378">While parallel operations (primary/secondary) are a powerful tool to model scenarios like when a machine and an operator are both needed to perform a specific task, it is also the source of many performance issues.</span></span> <span data-ttu-id="e7b20-379">Jei konkretaus atskiro ištekliaus reikalavimas kartu priskiriamas pirminei ir antrinei operacijai, dažniausiai tai nėra problema.</span><span class="sxs-lookup"><span data-stu-id="e7b20-379">If a requirement for a specific individual resource is assigned to both the primary and secondary operation, it is typically not a problem.</span></span> <span data-ttu-id="e7b20-380">Tačiau jei yra daug galimų išteklių kiekvienai iš operacijų, tai žymiai padidina skaičiavimo sudėtingumą planuojant.</span><span class="sxs-lookup"><span data-stu-id="e7b20-380">But if there are many possible resources for each of the operations, then it adds significant computational complexity to the scheduling.</span></span>

<span data-ttu-id="e7b20-381">Užduot naudojus lygiagrečias operacijas galima modeliuoti „virtualių“ išteklių poras (kurios atitiks komandą, kuri operacijoje visada yra kartu) arba vienos iš operacijų paprasčiausiai galima nemodeliuoti, jei ji nėra ribojanti.</span><span class="sxs-lookup"><span data-stu-id="e7b20-381">An alternative to using parallel operations is either to model the pairs as "virtual" resources (which will then represent the team that always goes together for the operation) or to simply not model one of the operations if it doesn't represent a bottleneck.</span></span>

### <a name="route-with-quantity-of-resources-higher-than-1"></a><span data-ttu-id="e7b20-382">Maršrutas, kurio išteklių kiekis yra didesnis už 1</span><span class="sxs-lookup"><span data-stu-id="e7b20-382">Route with quantity of resources higher than 1</span></span>

<span data-ttu-id="e7b20-383">Jeigu nustatytas operacijai reikalingų išteklių kiekis yra didesnis už vienetą, tada rezultatas bus toks pats kaip naudojant pirmines / antrines operacijas, nes mechanizmui siunčiamos kelios lygiagrečios užduotys.</span><span class="sxs-lookup"><span data-stu-id="e7b20-383">If setting the quantity of resources needed for an operation higher than one, then it results effectively the same as using primary/secondary operations because multiple parallel jobs are sent to the engine.</span></span> <span data-ttu-id="e7b20-384">Tačiau šiuo atveju nėra galimybės naudoti konkrečius ištekliaus priskyrimus, nes kiekiui, kuris yra didesnis už vienetą, reikia, kad operacijai būtų taikomas daugiau nei vienas išteklius.</span><span class="sxs-lookup"><span data-stu-id="e7b20-384">However, for this case there is not an option of using specific resource assignments, because a quantity higher than one requires that more than one resource is applicable for the operation.</span></span>

### <a name="excessive-use-of-finite-capacity"></a><span data-ttu-id="e7b20-385">Didelis riboto pajėgumo naudojimas</span><span class="sxs-lookup"><span data-stu-id="e7b20-385">Excessive use of finite capacity</span></span>

<span data-ttu-id="e7b20-386">Norint naudoti ribotą pajėgumą, reikia, kad mechanizmas iš duomenų bazės įkeltų pajėgumo informaciją ir tai gali padidinti skaičiavimo apkrovą, nes bus sunkiau rasti sprendimą, ypač aplinkose, kur išteklių rezervavimas beveik siekia maksimalų pajėgumą.</span><span class="sxs-lookup"><span data-stu-id="e7b20-386">Use of finite capacity requires the engine to load the capacity information from a database and can have a computational overhead because it will be harder to find a solution especially in environments where the resources are booked close to their maximum capacity.</span></span> <span data-ttu-id="e7b20-387">Dėl šios priežasties svarbu atidžiai įvertinti, ar ištekliui tikrai būtina naudoti ribotą pajėgumą ar jis gali būti išnaudojamas virš ribos.</span><span class="sxs-lookup"><span data-stu-id="e7b20-387">As a result, it is important to carefully evaluate if a resource really needs to use finite capacity or they can be overbooked.</span></span> <span data-ttu-id="e7b20-388">Kadangi riboto pajėgumo ištekliai gali skirtis pagal tai, kaip svarbu jų neišnaudoti virš ribos, rekomenduojame ribojimo parinktį ištekliui naudoti kartu su atskira plano „Ribojančių išteklių pajėgumo laiko riba“ verte.</span><span class="sxs-lookup"><span data-stu-id="e7b20-388">Because there might be a difference among finite capacity resources in how important they are not to overbook, we recommend using the bottleneck option on a resource in combination with a separate value on the plan in "Capacity time fence for bottleneck resources".</span></span> <span data-ttu-id="e7b20-389">Naudojant ribojimo koncepciją galima užtikrinti mažesnę bendrojo riboto pajėgumo laiko ribą.</span><span class="sxs-lookup"><span data-stu-id="e7b20-389">Using the bottleneck concept can enable that the general finite capacity time fence can be lowered.</span></span>

### <a name="setting-hard-links"></a><span data-ttu-id="e7b20-390">Kietųjų saitų nustatymas</span><span class="sxs-lookup"><span data-stu-id="e7b20-390">Setting hard links</span></span>

<span data-ttu-id="e7b20-391">Įprastas maršruto saito tipas yra *minkštasis*, o tai reiškia, kad tarp vienos operacijos pabaigos laiko ir kitos operacijos pradžios laiko leidžiamas laiko tarpas.</span><span class="sxs-lookup"><span data-stu-id="e7b20-391">The standard link type of the route is *soft*, which means that a time gap is allowed between the finishing time of one operation and the start of the next.</span></span> <span data-ttu-id="e7b20-392">Tokiu būdu gali susidaryti nepageidaujama situacija, kai vienai iš operacijų labai ilgą laiką neturint medžiagų arba pajėgumų, gamyba kurį laika gali vykti tuščiąja eiga, o tai gali reikšti atliekamo darbo apimties padidėjimą.</span><span class="sxs-lookup"><span data-stu-id="e7b20-392">Allowing this can have the unfortunate effect that, if materials or capacity are not available for one of the operations for a very long time, the production could be idle for quite a while, meaning a possible increase of work in progress.</span></span> <span data-ttu-id="e7b20-393">Tai negali įvykti naudojant kietuosius saitus, nes pabaigos ir pradžios laikai turi visiškai sutapti.</span><span class="sxs-lookup"><span data-stu-id="e7b20-393">This will not happen with hard links because the finish and start must align perfectly.</span></span> <span data-ttu-id="e7b20-394">Tačiau nustačius kietuosius saitus planavimo problema tampa sudėtingesnė, nes dviem operacijų ištekliams reikia skaičiuoti darbo laiko ir pajėgumų sankirtas.</span><span class="sxs-lookup"><span data-stu-id="e7b20-394">But setting hard links makes the scheduling problem more difficult because working time and capacity intersections must be calculated for the two resources of the operations.</span></span> <span data-ttu-id="e7b20-395">Jei kartu atliekamos lygiagrečios operacijos, tai žymiai padidina skaičiavimo laiką.</span><span class="sxs-lookup"><span data-stu-id="e7b20-395">If there are also parallel operations involved, this adds significant computational time.</span></span> <span data-ttu-id="e7b20-396">Jei dviejų operacijų ištekliai turi skirtingus kalendorius, kurie iš viso nepersidengia, problema yra neišsprendžiama.</span><span class="sxs-lookup"><span data-stu-id="e7b20-396">If the resources of the two operations have different calendars that don't overlap at all, the problem is unsolvable.</span></span>

<span data-ttu-id="e7b20-397">Kietuosius saitus rekomenduojame naudoti tik tada, kai tai yra neišvengiama – kiekvienai maršruto operacijai įvertinkite, ar tai yra būtina.</span><span class="sxs-lookup"><span data-stu-id="e7b20-397">We recommend using hard links only when strictly necessary, and carefully consider if it is necessary for each operation of the route.</span></span>

<span data-ttu-id="e7b20-398">Norint sumažinti atliekamų darbų apimtį ir nenaudoti kietųjų saitų, užsakymą galima planuoti du kartus, antrąjį kartą pakeičiant kryptį.</span><span class="sxs-lookup"><span data-stu-id="e7b20-398">To reduce the work in progress without applying hard links, a trick is to schedule the order twice with changing to the opposite direction for the second pass.</span></span> <span data-ttu-id="e7b20-399">Jei pirmas grafikas buvo apskaičiuotas atgal nuo pristatymo datos, antrasis turi būti apskaičiuotas į priekį nuo suplanuotos pradžios datos.</span><span class="sxs-lookup"><span data-stu-id="e7b20-399">If the first schedule was done backwards from delivery date, then the second should be done forward from the scheduled start date.</span></span> <span data-ttu-id="e7b20-400">Tokiu būdu užduočių apimtis bus sumažinta, kiek įmanoma, kad būtų kuo labiau sumažintas atliekamų darbų kiekis.</span><span class="sxs-lookup"><span data-stu-id="e7b20-400">This will result in the jobs being compressed as much as possible so that the work in progress is minimized.</span></span>

### <a name="separate-calendar-for-each-resource"></a><span data-ttu-id="e7b20-401">Atskiras kiekvieno ištekliaus kalendorius</span><span class="sxs-lookup"><span data-stu-id="e7b20-401">Separate calendar for each resource</span></span>

<span data-ttu-id="e7b20-402">Vienas iš pagrindinių planavimo mechanizmo duomenų šaltinių yra kalendoriaus informacija, kurios įkėlimui iš duomenų bazės gali reikėti daug išteklių.</span><span class="sxs-lookup"><span data-stu-id="e7b20-402">One of the main sources of data for the scheduling engine is calendar information, which can be expensive to load from the database.</span></span> <span data-ttu-id="e7b20-403">Kadangi kalendoriai yra generuojami remiantis šablonais, gali kilti noras generuoti kalendorių kiekvienam ištekliui ir tada koreguoti šio kalendoriaus informaciją, kai ištekliaus negalima naudoti arba kyla kitų problemų.</span><span class="sxs-lookup"><span data-stu-id="e7b20-403">Because calendars are generated based on templates, it would be tempting to generate a calendar for each resource and then adjust the information in this calendar when the resource has downtime and other issues.</span></span> <span data-ttu-id="e7b20-404">Tačiau tai labai riboja mechanizmo galimybę kaupti kalendoriaus duomenis, nes kiekvienam ištekliui reikės naujų duomenų, o tai gali būti rimta efektyvumo problemų priežastis.</span><span class="sxs-lookup"><span data-stu-id="e7b20-404">However, doing this will severely limit the engines ability to cache the calendar data as it would need to request new data for each resource and can be a large source of performance problems.</span></span> <span data-ttu-id="e7b20-405">Užuot tai darius, rekomenduojame, kiek įmanoma, ištekliams naudoti bendrus kalendorius, o tada kontroliuoti prastovų pakeitimus laikotarpiui priskiriant kitą kalendoriaus ID.</span><span class="sxs-lookup"><span data-stu-id="e7b20-405">Instead, we recommend that you reuse the calendars as much as possible between the resources, and then control downtime changes by assigning a different calendar ID for a period.</span></span>

### <a name="high-number-of-working-time-slots-per-calendar-day"></a><span data-ttu-id="e7b20-406">Didelis darbo laiko intervalų skaičius per dieną kalendoriuje</span><span class="sxs-lookup"><span data-stu-id="e7b20-406">High number of working time slots per calendar day</span></span>

<span data-ttu-id="e7b20-407">Kadangi mechanizmas veikia po vieną pagal pajėgumą nagrinėdamas laiko intervalus, naudinga kuo labiau sumažinti kalendoriaus dienos laiko intervalų skaičių.</span><span class="sxs-lookup"><span data-stu-id="e7b20-407">Because the engine works by examining time slots one-by-one for capacity, it is beneficial to minimize the number of time slots per calendar day.</span></span> <span data-ttu-id="e7b20-408">Tai galima padaryti, pavyzdžiui, nusprendžiant, ar svarbu, kad gautame grafike būtų atsižvelgta į tai, kad darbuotojai kas valandą turi 5 minučių pertraukėlę.</span><span class="sxs-lookup"><span data-stu-id="e7b20-408">This could be done, for example, by considering whether it's important for the resulting schedule to reflect that workers have a 5-minute break every hour.</span></span>

### <a name="large-or-none-scheduling-timeouts"></a><span data-ttu-id="e7b20-409">Ilgas (arba jokio) planavimo skirtasis laikas</span><span class="sxs-lookup"><span data-stu-id="e7b20-409">Large (or none) scheduling timeouts</span></span>

<span data-ttu-id="e7b20-410">Planavimo mechanizmo efektyvumą galima optimizuoti naudojant parametrus, pateiktus puslapyje **Planavimo parametrai**.</span><span class="sxs-lookup"><span data-stu-id="e7b20-410">Scheduling engine performance can be optimized using parameters found on the **Scheduling parameters** page.</span></span> <span data-ttu-id="e7b20-411">Parametrų **Planavimo skirtasis laikas įjungtas** ir **Planavimo optimizavimo skirtasis laikas įjungtas** reikšmė visada turi būti **Taip**.</span><span class="sxs-lookup"><span data-stu-id="e7b20-411">The **Scheduling timeout enabled** and **Scheduling optimization timeout enabled** settings should always be set to **Yes**.</span></span> <span data-ttu-id="e7b20-412">Jei reikšmė yra **Ne**, planavimas gali vykti be galo, jei sukurtas prastas maršrutas su daugeliu galimybių.</span><span class="sxs-lookup"><span data-stu-id="e7b20-412">If set to **No**, the scheduling can potentially run infinitely if an unfeasible route with many options has been created.</span></span>

<span data-ttu-id="e7b20-413">**Maksimalus planavimo laikas sekai** reikšmė nurodo, kiek sekundžių gali būti skirta bandymui rasti vienos sekos sprendimą (daugeliu atvejų seka atitinka vieną užsakymą).</span><span class="sxs-lookup"><span data-stu-id="e7b20-413">The value for **Maximum scheduling time per sequence** controls how many seconds can, at most, be spent trying to find a solution for a single sequence (in most cases a sequence corresponds to a single order).</span></span> <span data-ttu-id="e7b20-414">Čia pateikta reikšmė labai priklauso nuo maršruto sudėtingumo ir tokių parametrų kaip ribotas pajėgumas, tačiau maksimali 30 sekundžių reikšmė gali būti geras pradinis pasirinkimas.</span><span class="sxs-lookup"><span data-stu-id="e7b20-414">The value to use here highly depends on the complexity of the route and settings like finite capacity, ut a maximum of about 30 seconds is a good starting point.</span></span>

<span data-ttu-id="e7b20-415">**Optimizavimo bandymų skirtasis laikas** reikšmė nurodo, kiek sekundžių gali būti skirta rasti sprendimui, kuris yra geresnis už rastą prieš tai.</span><span class="sxs-lookup"><span data-stu-id="e7b20-415">The value for **Optimization attempts timeout** controls how many seconds can at most be used to find a better solution than the one originally found.</span></span> <span data-ttu-id="e7b20-416">Tai turės įtakos tik maršrutams, kurie naudoja lygiagrečias operacijas, nes joms būtina išbandyti skirtingus derinius.</span><span class="sxs-lookup"><span data-stu-id="e7b20-416">This will only influence routes that are using parallel operations as these make it necessary to test different combinations.</span></span>

> [!NOTE]
> <span data-ttu-id="e7b20-417">Nustatytos skirtojo laiko reikšmės bus taikomos paskelbtų gamybos užsakymų ir suplanuotų užsakymų planavimui, kuris yra MRP dalis.</span><span class="sxs-lookup"><span data-stu-id="e7b20-417">The values set for the timeouts will be applied both for scheduling of released production orders and of planned orders as part of MRP.</span></span> <span data-ttu-id="e7b20-418">Todėl nustačius labai dideles reikšmes gali žymiai pailgėti MRP vykdymo laikas, jei vykdomas planas su daugeliu suplanuotų gamybos užsakymų.</span><span class="sxs-lookup"><span data-stu-id="e7b20-418">As a result, setting very high values could significantly add to the run time of MRP when running for a plan with many planned production orders.</span></span>
